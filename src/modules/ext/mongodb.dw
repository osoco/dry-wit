# mod: mongodb
# api: public
# txt: MongoDB module.

DW.import process;

# fun: enableMongodbCrAuthentication
# api: public
# txt: Enables MONGODB-CR authentication.
# txt: Returns 0/TRUE if MONGODB-CR gets enabled successfully; 1/FALSE otherwise.
# use: if enableMongodbCrAuthentication; then
# use:   echo "MONGODB-CR enabled successfully";
# use: fi
function enableMongodbCrAuthentication() {
  local _output;

  _output="$(mongo admin --eval "var schema = db.system.version.findOne({'_id' : 'authSchema'}); if (schema != undefined) { schema.currentVersion = 3; db.system.version.save(schema); } else { db.system.version.insert({'_id' : 'authSchema', 'currentVersion' : 3 }); }")";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

   return ${_rescode};
}

# fun: addMongodbAdminUser user password authenticationDatabase?
# api: public
# txt: Adds an admin user.
# opt: user: The user.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to "admin".
# txt: Returns 0/TRUE if the user gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongodbAdminUser "admin" "secret"; then
# use:   echo "User admin created successfully";
# use: fi
function addMongoDbAdminUser() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _authenticationDatabase="${3}";
  if isEmpty "${_authenticationDatabase}"; then
    _authenticationDatabase="admin";
  fi

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_authenticationDatabase}
db.createRole(
  {
    role: "superRoot",
    privileges: [
      {
        "resource": { anyResource: true }, actions: ['anyAction']
      }
    ],
    roles: [ ]
  }
)
db.createUser(
  {
    user: "${_user}",
    pwd: "${_password}",
    roles: [
      { role: "superRoot", db: "${_authenticationDatabase}" }
    ]
  }
)
EOF
  local _output;
  _output="$(cat "${_tmpFile}" | mongo 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: addMongoDbBackupRole roleName root rootPassword authenticationDatabase? authenticationMechanism?
# api: public
# txt: Adds a backup role (includes both "backup" and "restore").
# opt: roleName: The role name. It must not match any of the built-in roles.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256
# txt: Returns 0/TRUE if the role gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongoDbBackupRole "backupRestore" myDb root "s3cr3t"; then
# use:   echo "Role backupRestore created successfully";
# use: fi
function addMongoDbBackupRole() {
  local _roleName="${1}";
  checkNotEmpty roleName "${_roleName}" 1;
  local _database="${2}";
  checkNotEmpty database "${_database}" 2;
  local _root="${3}";
  checkNotEmpty root "${_root}" 3;
  local _rootPassword="${4}";
  checkNotEmpty rootPassword "${_rootPassword}" 4;
  local _authenticationDatabase="${5}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5;
  local _authenticationMechanism="${6}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_authenticationDatabase}
db.createRole(
  {
    role: "${_roleName}",
    privileges: [],
    roles: [
      { role: "backup", db: "${_authenticationDatabase}" },
      { role: "restore", db: "${_authenticationDatabase}" },
      { role: "dbAdminAnyDatabase", db: "${_authenticationDatabase}" }
    ]
  }
)
EOF
  local _output;
  _output="$(cat "${_tmpFile}" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  echo "${_output}";

  return ${_rescode};
}

# fun: mongoDbRoleAlreadyExists roleName root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Checks if giwen role already exists.
# opt: roleName: The role name.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the role exists already; 1/FALSE otherwise.
# use: if mongoDbRoleAlreadyExists "EventSourcingEventView" myDb root "s3cr3t" admin SCRAM-SHA-256; then
# use:   echo "Role already exists";
# use: i
function mongoDbRoleAlreadyExists() {
  local _roleName="${1}";
  checkNotEmpty roleName "${_roleName}" 1;
  local _database="${2}";
  checkNotEmpty database "${_database}" 2;
  local _root="${3}";
  checkNotEmpty root "${_root}" 3;
  local _rootPassword="${4}";
  checkNotEmpty rootPassword "${_rootPassword}" 4;
  local _authenticationDatabase="${5}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5;
  local _authenticationMechanism="${6}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6;

  local _output;
  _output="$(echo "db.getRole(\"${_roleName}\")" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}"  --quiet "${_authenticationDatabase}" | grep -v -e '^switched to db ' | jq '.role' | sed 's ^"  g' | sed 's "$  g' | grep --color=none -e "^${_roleName}$" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    _output="$(echo "db.getRole(\"${_roleName}\")" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}"  --quiet "${_authenticationDatabase}" 2>&1)";
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: addMongoDbRole roleName root rootPassword authenticationDatabase authenticationMechanism privilegeSpec? roleSpec?
# api: public
# txt: Adds a role.
# opt: roleName: The role name. It must not match any of the built-in roles.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: privilegeSpec: The privilege spec.
# opt: roleSpec: the role spec.
# txt: Returns 0/TRUE if the role gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongoDbRole "EventSourcingEventView" myDb root "s3cr3t" admin SCRAM-SHA-256 "[ { db: 'core', collection: 'eventSourcingEvent'}, actions: ['find'] } ]" '[]'; then
# use:   echo "Role created successfully";
# use: i
function addMongoDbRole() {
  local _roleName="${1}";
  checkNotEmpty roleName "${_roleName}" 1;
  local _database="${2}";
  checkNotEmpty database "${_database}" 2;
  local _root="${3}";
  checkNotEmpty root "${_root}" 3;
  local _rootPassword="${4}";
  checkNotEmpty rootPassword "${_rootPassword}" 4;
  local _authenticationDatabase="${5}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5;
  local _authenticationMechanism="${6}";
  checkNotEmpty authMechanism "${_authenticationMechanism}" 6;
  local _privilegeSpec="${7}";
  checkNotEmpty privilegeSpec "${_privilegeSpec}" 7;
  local _roleSpec="${8}";
  checkNotEmpty roleSpec "${_roleSpec}" 8;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_database}
db.createRole(
  {
    role: "${_roleName}",
    privileges: ${_privilegeSpec},
    roles: ${_roleSpec}
  }
)
EOF
  local _output;
  _output="$(cat "${_tmpFile}" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: addMongoDbUser user password database root rootPassword authenticationDatabase authenticationMechanism roleSpec+
# api: public
# txt: Adds a new user.
# opt: user: The user.
# opt: password: The password.
# opt: database: The user database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: roleSpec: The space-separated list of role names.
# txt: Returns 0/TRUE if the user gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if addMongoDbUser "my-user" "secret" "myDb" "root" "s3cr3t" "admin" "SCRAM-SHA-256" "{ role: 'userAdmin', db: 'admin' }""; then
# use:   echo "User admin created successfully";
# use: fi
function addMongoDbUser() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  shift;
  local _password="${1}";
  checkNotEmpty password "${_password}" 2;
  shift;
  local _database="${1}";
  checkNotEmpty database "${_database}" 3;
  shift;
  local _root="${1}";
  checkNotEmpty root "${_root}" 4;
  shift;
  local _rootPassword="${1}";
  checkNotEmpty rootPassword "${_rootPassword}" 5;
  shift;
  local _authenticationDatabase="${1}";
  checkNotEmpty authenticationaDtabase "${_authenticationDatabase}" 6;
  shift;
  local _authenticationMechanism="${1}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 7;
  shift;
  local _roleSpec="${@}";
  checkNotEmpty roleSpec "${_roleSpec}" 8;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_database}
db.createUser(
  {
    user: "${_user}",
    pwd: "${_password}",
    roles: ${_roleSpec}
  }
)
EOF
  local _output;
  _output="$(cat "${_tmpFile}" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: mongoDbFreeMonitoringAlreadyEnabled root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Checks if free monitoring on the instance is already enabled.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the free monitoring is enabled; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the monitoring url; else, the variable ERROR contains some error information.
# use: if mongoDbFreeMonitoringAlreadyEnabled "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then
# use:   echo "Free monitoring enabled";
# use: fi
function mongoDbFreeMonitoringAlreadyEnabled() {
  local _root="${1}";
  checkNotEmpty root "${_root}" 1;
  local _rootPassword="${2}";
  checkNotEmpty rootPassword "${_rootPassword}" 2;
  local _authenticationDatabase="${3}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4;
  local _output;

  _output="$(echo "db.getFreeMonitoringStatus()" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    _result="$(echo "${_output}" | grep '"url"' | awk '{print $3;}' | cut -d'"' -f 2)";
    export RESULT="${_result}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: enableMongoDbFreeMonitoring root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Enables free monitoring on the instance.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the free monitoring gets enabled; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the monitoring url; else, the variable ERROR contains some error information.
# use: if enableMongoDbFreeMonitoring "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then
# use:   echo "Free monitoring enabled";
# use: fi
function enableMongoDbFreeMonitoring() {
  local _root="${1}";
  checkNotEmpty root "${_root}" 1;
  local _rootPassword="${2}";
  checkNotEmpty rootPassword "${_rootPassword}" 2;
  local _authenticationDatabase="${3}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4;
  local _output;

  _output="$(echo "db.enableFreeMonitoring()" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    _result="$(echo "${_output}" | grep '"url"' | awk '{print $3;}' | cut -d'"' -f 2)";
    export RESULT="${_result}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: disableMongoDbFreeMonitoring root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Disables free monitoring on the instance.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the free monitoring gets disabled; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if disableMongoDbFreeMonitoring "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then echo "Free monitoring enabled"; fi
function disableMongoDbFreeMonitoring() {
  local _root="${1}";
  checkNotEmpty root "${_root}" 1;
  local _rootPassword="${2}";
  checkNotEmpty rootPassword "${_rootPassword}" 2;
  local _authenticationDatabase="${3}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4;
  local _output;

  _output="$(echo "db.disableFreeMonitoring()" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: isMongodRunning
# api: public
# txt: Checks whether mongod is running.
# txt: Returns 0/TRUE if it's running; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE; the variable RESULT contains the mongod pid.
# use: if ! isMongodRunning; then
# use:   echo "mongod is not running";
# use: fi
function isMongodRunning() {
  isRunning $(which mongod);
}

# fun: killMongod
# api: public
# txt: Kills the current mongod process.
# txt: Returns 0/TRUE if the process is killed; 1/FALSE otherwise.
# use: if killMongod; then
# use:   echo "mongod process killed successfully";
# use: fi
function killMongod() {
  local _pids;

  local -i _rescode=${TRUE};

  logInfo "Killing mongod process";
  if isMongodRunning; then
    _pids="${RESULT}";
    echo ${_pids} | xargs kill;
    _rescode=$?;
    logInfo -n "Killing mongod process";
    if isTrue ${_rescode}; then
      logInfoResult SUCCESS "done";
    else
      logInfoResult FAILURE "failed";
    fi
  else
    logInfoResult SUCCESS "not running";
  fi

  return ${_rescode};
}

# fun: mongoDump output host user? pass? authenticationDatabase? authenticationMechanism?
# api: public
# txt: Performs a dump (gzipped, using the MongoDB archive format)
# opt: output: The output file.
# opt: host: The host. Optional. Defaults to localhost.
# opt: user: The user name. Optional.
# opt: pass: The password. Optional.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA1.
# txt: Returns 0/TRUE if the dump gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR would contain some information about the error.
# use: if mongoDump /tmp/dump-today.gz localhost root secret; then
# use:   echo "dump succeeded";
# use: fi
function mongoDump() {
  local _output="${1}";
  checkNotEmpty output "${_output}" 1;
  local _host="${2:-localhost}";
  checkNotEmpty host "${_host}" 2;
  local _user="${3}";
  local _pass="${4}";
  local _authenticationDatabase="${5:-admin}";
  local _authenticationMechanism="${6:-SCRAM-SHA1}";

  local -i _rescode;
  local _output;

  checkReq mongodump;

  if isEmpty "${_user}"; then
    _output="$(mongodump --gzip --archive="${_output}" -h ${_host} 2>&1)";
    _rescode=$?;
  else
    _output="$(mongodump --gzip --archive="${_output}" -h ${_host} -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} 2>&1)";
    _rescode=$?;
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: mongoRestore file host? user? pass? authenticationDatabase? authenticationMechanism?
# api: public
# txt: Restores from backup.
# opt: file: The file to restore from.
# opt: host: The host. Optional. Defaults to localhost.
# opt: user: The user name. Optional.
# opt: password: The password. Optional.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256.
# txt: Returns 0/TRUE if the restore process succeeds; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains additional information.
# use: if mongoRestore "/tmp/dump.gz"; then
# use:   echo "Backup /tmp/dump.gz restored successfully";
# use: fi
function mongoRestore() {
  local _file="${1}";
  checkNotEmpty file "${_file}" 1;

  local _host="${2:-localhost}";
  local _user="${3}";
  local _pass="${4}";
  local _authenticationDatabase="${5:-admin}";
  local _authenticationMechanism="${6:-SCRAM-SHA-256}";
  local _database="${7}";

  if isNotEmpty "${_database}"; then
    _database="-d ${_database}";
  fi

  local -i _rescode;
  local _output;

  if isEmpty "${_user}"; then
    _output="$(mongoimport -h ${_host} ${_database} "${_file}" 2>&1)";
    _rescode=$?;
  else
    _output="$(mongoimport -h ${_host} -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} ${_database} "${_file}" 2>&1)";
    _rescode=$?;
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: startMongodWithAuthenticationDisabled user group permissionsFolder configFile
# api: public
# txt: Starts mongod with authentication enabled, using given user and group (and ensuring its permissions match the owners of given permissionsFolder parameter).
# opt: user: The owner of the process.
# opt: group: The group of the process.
# opt: permissionsFolder: The folder used to get the permissions from (the user and group will be adapted to match the folder's).
# opt: configFile: The mongod config file.
# txt: Returns 0/TRUE if the process could be started; 1/FALSE otherwise.
# use: startMongodbWithAuthenticationDisabled mongo mongo /var/lib/mongodb /etc/mongod.conf & disown;
function startMongodWithAuthenticationDisabled() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _group="${2}";
  checkNotEmpty group "${_group}" 2;
  local _permissionsFolder="${3}";
  checkNotEmpty permissionsFolder "${_permissionsFolder}" 3;
  local _configFile="${4}";
  checkNotEmpty configFile "${_configFile}" 4;

  checkReq run-as.sh;
  checkReq mongod;

  resolveVerbosity;
  local _verbosity="${RESULT}";

  chmod a+x "${_permissionsFolder}";

  run-as.sh ${_verbosity} -U ${_user} -G ${_group} -- "${_permissionsFolder}" mongod --config "${_configFile}";
  local -i _rescode=$?;

  return ${_rescode};
}

# fun: startMongodWithAuthenticationEnabled user group permissionsFolder configFile authenticationMechanism
# api: public
# txt: Starts mongod with authentication enabled, using given user and group (and ensuring its permissions match the owners of given permissionsFolder parameter).
# opt: user: The owner of the process.
# opt: group: The group of the process.
# opt: permissionsFolder: The folder used to get the permissions from (the user and group will be adapted to match the folder's).
# opt: configFile: The mongod config file.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the process could be started; 1/FALSE otherwise.
# use: startMongodbWithAuthenticationEnabled mongo mongo /var/lib/mongodb /etc/mongod.conf SCRAM-SHA-256 & disown;
function startMongodWithAuthenticationEnabled() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _group="${2}";
  checkNotEmpty group "${_group}" 2;
  local _permissionsFolder="${3}";
  checkNotEmpty permissionsFolder "${_permissionsFolder}" 3;
  local _configFile="${4}";
  checkNotEmpty configFile "${_configFile}" 4;
  local _authenticationMechanism="${5}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 5;

  checkReq run-as.sh;
  checkReq mongod;

  resolveVerbosity;
  local _verbosity="${RESULT}";

  chmod a+x "${_permissionsFolder}";

  run-as.sh ${_verbosity} -U ${_user} -G ${_group} -- "${_permissionsFolder}" mongod --config "${_configFile}" --auth --setParameter authenticationMechanisms=${_authenticationMechanism};
  local -i _rescode=$?;

  return ${_rescode};
}

# fun: waitUntilMongodIsRunning timeout checkInterval
# api: public
# txt: Waits until mongod is running.
# opt: timeout: The maximum number of seconds to wait.
# opt: checkInterval: How often to check.
# txt: Returns 0/TRUE if mongod is running; 1/FALSE if it didn't start after the timeout expired.
# use: if waitUntilMongodIsRunning 60 5; then
# use:   echo "Mongod is running";
# use: fi
function waitUntilMongodIsRunning() {
  local -i _timeout=${1};
  checkNumber timeout "${_timeout}" 1;
  local -i _checkInterval=${2};
  checkNumber checkInterval "${_checkInterval}" 2;

  local -i _rescode=${TRUE};
  local -i _attempts=0;

  while ! isMongodRunning; do
    add ${_attempts} 1;
    _attempts=${RESULT};
    multiply ${_attempts} ${_checkInterval};
    local -i _currentWait=${RESULT};
    if isLessThan ${_timeout} ${_currentWait}; then
      _rescode=${FALSE};
      break;
    fi
    sleep ${_checkInterval};
  done

  return ${_rescode};
}

# fun: isMongodRunning
# api: public
# txt: Checks mongod is not running.
# txt: Returns 0/TRUE if mongod is running; 1/FALSE otherwise.
# use: if isMongodRunning; then
# use:   echo "mongod is running";
# use: fi
function isMongodRunning() {
  DW.import process;

  isRunning $(which mongod);
}

# fun: isMongodRunningWithNoAuthentication
# api: public
# txt: Checks mongod is running with no authentication.
# txt: Returns 0/TRUE if mongod is running with no authentication enabled; 1/FALSE otherwise.
# use: if isMongodRunningWithNoAuthentication; then
# use:   echo "Mongod is not running, or it's running with auth enabled";
# use: fi
function isMongodRunningWithNoAuthentication() {
  local -i _rescode=${FALSE};

  if isMongodRunning; then
    ps -ef | grep --color=none $(which mongod) | grep --color=none -v " --auth " | grep -v grep > /dev/null 2>&1;
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: checkMongoUserCanLogin user password authenticationDatabase authenticationMechanism
# api: public
# txt: Checks given MongoDB user can login.
# opt: user: The user name.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if given user can log in; 1/FALSE otherwise.
# use: if checkMongoUserCanLogIn root secret admin SCRAM-SHA-256; then echo "User can log in"; fi
function checkMongoUserCanLogIn() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _authenticationDatabase="${3}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "{_authenticationMechanism}" 4;

  local _output;

  _output="$(mongo -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" --eval "{ ping: 1 }" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: createMongoDbIndex user password authenticationDatabase authenticationMechanism database collection index options
# api: public
# txt: Creates a MongoDB index on given collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: database: The database of the collection.
# opt: collection: The collection.
# opt: index: The index.
# opt: options: The index options.
# txt: Returns 0/TRUE if the index could be created; 1/FALSE otherwise.
# use: if createMongoDbIndex root secret admin SCRAM-SHA-1 myDatabase myCollection '{ id: 1 }' '{ name: "myIndex" }'; then
# use:   echo "Index created successfully";
# use: fi
function createMongoDbIndex() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _authenticationDatabase="${3}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4;
  local _database="${5}";
  checkNotEmpty collection "${_database}" 5;
  local _collection="${6}";
  checkNotEmpty collection "${_collection}" 6;
  local _index="${7}";
  checkNotEmpty index "${_index}" 7;
  local _options="${8}";
  checkNotEmpty options "${_options}" 8;

  _output="$(mongo -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_database}" --eval "db.${_collection}.createIndex(${_index},${_options})" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: mongoDbIndexAlreadyExists user password authenticationDatabase authenticationMechanism database collection index
# api: public
# txt: Checks a MongoDB index exists on given collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: database: The database.
# opt: collection: The collection.
# opt: index: The index.
# txt: Returns 0/TRUE if the index exists; 1/FALSE otherwise.
# use: if mongoDbIndexAlreadyExists root secret admin SCRAM-SHA-1 myDatabase myCollection '{ id: 1 }'; then
# use:   echo "Index exists";
# use: fi
function mongoDbIndexAlreadyExists() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _authenticationDatabase="${3}";
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4;
  local _database="${5}";
  checkNotEmpty database "${_database}" 5;
  local _collection="${6}";
  checkNotEmpty collection "${_collection}" 6;
  local _index="${7}";
  checkNotEmpty index "${_index}" 7;

  local _output;

  _output="$(mongo -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_database}" --eval "var indexes = db.getCollection('${_collection}').getIndexes(); var exists = false; for (var i=0; i < indexes.length; i++) { if (indexes[i].name == '${_index}') { exists = true; break; } }; print(exists);" 2>&1)";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_output}";
  else
    export ERROR="${_output}";
  fi

  return ${_rescode};
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
