# mod: mongodb
# api: public
# txt: MongoDB module.

DW.import process;

# fun: enableMongodbCrAuthentication
# api: public
# txt: Enables MONGODB-CR authentication.
# txt: Returns 0/TRUE if MONGODB-CR gets enabled successfully; 1/FALSE otherwise.
# use: if enableMongodbCrAuthentication; then echo "MONGODB-CR enabled successfully"; fi
function enableMongodbCrAuthentication() {
  local -i _rescode;

  local _output="$(mongo admin --eval "var schema = db.system.version.findOne({'_id' : 'authSchema'}); if (schema != undefined) { schema.currentVersion = 3; db.system.version.save(schema); } else { db.system.version.insert({'_id' : 'authSchema', 'currentVersion' : 3 }); }")";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    _rescode=${TRUE};
  fi

   return ${_rescode};
}

# fun: addMongodbRootUser user password authenticationDatabase?
# api: public
# txt: Adds the root user.
# opt: user: The user.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to "admin".
# txt: Returns 0/TRUE if the user gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongodbRootUser "admin" "secret"; then echo "User admin created successfully"; fi
function addMongoDbRootUser() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _authDb="${3}";
  if isEmpty "${_authDb}"; then
    _authDb="admin";
  fi

  local -i _rescode;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_authDb}
db.createRole(
  {
    role: "superRoot",
    privileges: [
      {
        "resource": { anyResource: true }, actions: ['anyAction']
      }
    ],
    roles: [ ]
  }
)
db.createUser(
  {
    user: "${_user}",
    pwd: "${_password}",
    roles: [
      { role: "superRoot", db: "${_authDb}" }
    ]
  }
)
EOF
  local _output="$(cat "${_tmpFile}" | mongo 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: addMongoDbBackupRole roleName root rootPassword authenticationDatabase? authenticationMechanism?
# api: public
# txt: Adds a backup role (includes both "backup" and "restore").
# opt: roleName: The role name. It must not match any of the built-in roles.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256
# txt: Returns 0/TRUE if the role gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongoDbBackupRole "backupRestore" myDb root "s3cr3t"; then echo "Role backupRestore created successfully"; fi
function addMongoDbBackupRole() {
  local _roleName="${1}";
  checkNotEmpty roleName "${_roleName}" 1;
  local _database="${2}";
  checkNotEmpty database "${_database}" 2;
  local _root="${3}";
  checkNotEmpty root "${_root}" 3;
  local _rootPassword="${4}";
  checkNotEmpty rootPassword "${_rootPassword}" 4;
  local _authDb="${5}";
  checkNotEmpty authenticationDatabase "${_authDb}" 5;
  local _authMechanism="${6}";
  checkNotEmpty authenticationDatabase "${_authDb}" 6;

  local -i _rescode;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_authDb}
db.createRole(
  {
    role: "${_roleName}",
    privileges: [],
    roles: [
      { role: "backup", db: "${_authDb}" },
      { role: "restore", db: "${_authDb}" },
      { role: "dbAdminAnyDatabase", db: "${_authDb}" }
    ]
  }
)
EOF
  local _output="$(cat "${_tmpFile}" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authDb}" --authenticationMechanism "${_authMechanism}" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: addMongoDbRole roleName root rootPassword authenticationDatabase authenticationMechanism privilegeSpec? roleSpec?
# api: public
# txt: Adds a role.
# opt: roleName: The role name. It must not match any of the built-in roles.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: privilegeSpec: The privilege spec.
# opt: roleSpec: the role spec.
# txt: Returns 0/TRUE if the role gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongoDbRole "EventSourcingEventView" myDb root "s3cr3t" admin SCRAM-SHA-256 "[ { db: 'core', collection: 'eventSourcingEvent'}, actions: ['find'] } ]" '[]'; then echo "Role created successfully"; fi
function addMongoDbRole() {
  local _roleName="${1}";
  checkNotEmpty roleName "${_roleName}" 1;
  local _database="${2}";
  checkNotEmpty database "${_database}" 2;
  local _root="${3}";
  checkNotEmpty root "${_root}" 3;
  local _rootPassword="${4}";
  checkNotEmpty rootPassword "${_rootPassword}" 4;
  local _authDb="${5}";
  checkNotEmpty authenticationDatabase "${_authDb}" 5;
  local _authMechanism="${6}";
  checkNotEmpty authenticationDatabase "${_authDb}" 6;
  local _privilegeSpec="${7}";
  checkNotEmpty privilegeSpec "${_privilegeSpec}" 7;
  local _roleSpec="${8}";
  checkNotEmpty roleSpec "${_roleSpec}" 8;
  local -i _rescode;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_authDb}
db.createRole(
  {
    role: "${_roleName}",
    privileges: ${_privilegeSpec},
    roles: ${_roleSpec}
  }
)
EOF
  local _output="$(cat "${_tmpFile}" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authDb}" --authenticationMechanism "${_authMechanism}" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    export RESULT="${_output}";
    _rescode=${TRUE};
  fi

  cat ${_tmpFile};

  return ${_rescode};
}

# fun: addMongoDbUser user password database root rootPassword authenticationDatabase authenticationMechanism roleSpec+
# api: public
# txt: Adds a new user.
# opt: user: The user.
# opt: password: The password.
# opt: database: The user database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: roleSpec: The space-separated list of role names.
# txt: Returns 0/TRUE if the user gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if addMongoDbUser "my-user" "secret" "myDb" "root" "s3cr3t" "admin" "SCRAM-SHA-256" "{ role: 'userAdmin', db: 'admin' }""; then echo "User admin created successfully"; fi
function addMongoDbUser() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  shift;
  local _password="${1}";
  checkNotEmpty password "${_password}" 2;
  shift;
  local _database="${1}";
  checkNotEmpty database "${_database}" 3;
  shift;
  local _root="${1}";
  checkNotEmpty root "${_root}" 4;
  shift;
  local _rootPassword="${1}";
  checkNotEmpty rootPassword "${_rootPassword}" 5;
  shift;
  local _authDb="${1}";
  checkNotEmpty authenticationDatabase "${_authDb}" 6;
  shift;
  local _authMechanism="${1}";
  checkNotEmpty authenticationMechanism "${_authMechanism}" 7;
  shift;
  local _roleSpec="${@}";
  checkNotEmpty roleSpec "${_roleSpec}" 8;
  local -i _rescode;

  createTempFile;
  local _tmpFile="${RESULT}";

  cat <<EOF > "${_tmpFile}"
use ${_database}
db.createUser(
  {
    user: "${_user}",
    pwd: "${_password}",
    roles: ${_roleSpec}
  }
)
EOF
  local _output="$(cat "${_tmpFile}" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authDb}" --authenticationMechanism "${_authenticationMechanism}" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    export RESULT="${_output}";
    _rescode=${TRUE};
  fi

  cat ${_tmpFile};

  return ${_rescode};
}

# fun: enableMongoDbFreeMonitoring root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Enables free monitoring on the instance.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the free monitoring gets enabled; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the monitoring url; else, the variable ERROR contains some error information.
# use: if enableMongoDbFreeMonitoring "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then echo "Free monitoring enabled"; fi
function enableMongoDbFreeMonitoring() {
  local _root="${1}";
  checkNotEmpty root "${_root}" 1;
  local _rootPassword="${2}";
  checkNotEmpty rootPassword "${_rootPassword}" 2;
  local _authDb="${3}";
  checkNotEmpty authenticationDatabase "${_authDb}" 3;
  local _authMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authMechanism}" 4;
  local -i _rescode;

  local _output="$(echo "db.enableFreeMonitoring()" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authDb}" --authenticationMechanism="${_authenticationMechanism}" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    _rescode=${TRUE};
    _result="$(echo "${_output}" | grep '"url"' | awk '{print $3;}' | cut -d'"' -f 2)";
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: disableMongoDbFreeMonitoring root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Disables free monitoring on the instance.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the free monitoring gets disabled; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if disableMongoDbFreeMonitoring "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then echo "Free monitoring enabled"; fi
function disableMongoDbFreeMonitoring() {
  local _root="${1}";
  checkNotEmpty root "${_root}" 1;
  local _rootPassword="${2}";
  checkNotEmpty rootPassword "${_rootPassword}" 2;
  local _authDb="${3}";
  checkNotEmpty authenticationDatabase "${_authDb}" 3;
  local _authMechanism="${4}";
  checkNotEmpty authenticationMechanism "${_authMechanism}" 4;
  local -i _rescode;

  local _output="$(echo "db.disableFreeMonitoring()" | mongo -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authDb}" --authenticationMechanism="${_authenticationMechanism}" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
    export ERROR="${_output}";
  else
    export RESULT="${_output}";
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: isMongodRunning
# api: public
# txt: Checks whether mongod is running.
# txt: Returns 0/TRUE if it's running; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE; the variable RESULT contains the mongod pid.
# use: if ! isMongodRunning; then echo "mongod is not running"; fi
function isMongodRunning() {
  isRunning $(which mongod);
}

# fun: killMongod
# api: public
# txt: Kills the current mongod process.
# txt: Returns 0/TRUE if the process is killed; 1/FALSE otherwise.
# use: if killMongod; then echo "mongod process killed successfully"; fi
function killMongod() {
  local _pids;

  local -i _rescode=${TRUE};

  logInfo "Killing mongod process";
  if isMongodRunning; then
    _pids="${RESULT}";
    echo ${_pids} | xargs kill;
    _rescode=$?;
    logInfo -n "Killing mongod process";
    if isTrue ${_rescode}; then
      logInfoResult SUCCESS "done";
    else
      logInfoResult FAILURE "failed";
    fi
  else
    logInfoResult SUCCESS "not running";
  fi

  return ${_rescode};
}

# fun: mongoDump output host user? pass? authDb? authMechanism?
# api: public
# txt: Performs a dump (gzipped, using the MongoDB archive format)
# opt: output: The output file.
# opt: host: The host. Optional. Defaults to localhost.
# opt: user: The user name. Optional.
# opt: pass: The password. Optional.
# opt: authDb: The authentication database. Optional. Defaults to admin.
# opt: authMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA1.
# txt: Returns 0/TRUE if the dump gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR would contain some information about the error.
# use: if mongoDump /tmp/dump-today.gz localhost root secret; then echo "dump succeeded"; fi
function mongoDump() {
  local _output="${1}";
  checkNotEmpty output "${_output}" 1;
  local _host="${2:-localhost}";
  checkNotEmpty host "${_host}" 2;
  local _user="${3}";
  local _pass="${4}";
  local _authDb="${5:-admin}";
  local _authMechanism="${6:-SCRAM-SHA1}";

  local -i _rescode;
  local _output;

  checkReq mongodump;

  if isEmpty "${_user}"; then
    _output="$(mongodump --gzip --archive="${_output}" -h ${_host} 2>&1)";
    _rescode=$?;
  else
    _output="$(mongodump --gzip --archive="${_output}" -h ${_host} -u ${_user} -p ${_pass} --authenticationDatabase=${_authDb} --authenticationMechanism=${_authMechanism} 2>&1)";
    _rescode=$?;
  fi

  if isFalse ${_rescode}; then
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: mongoRestore file host? user? pass? authenticationDatabase? authenticationMechanism?
# api: public
# txt: Restores from backup.
# opt: file: The file to restore from.
# opt: host: The host. Optional. Defaults to localhost.
# opt: user: The user name. Optional.
# opt: password: The password. Optional.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256.
# txt: Returns 0/TRUE if the restore process succeeds; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains additional information.
# use: if mongoRestore "/tmp/dump.gz"; then echo "Backup /tmp/dump.gz restored successfully"; fi
function mongoRestore() {
  local _file="${1}";
  checkNotEmpty file "${_file}" 1;

  local -i _rescode;

  local _host="${2:-localhost}";
  local _user="${3}";
  local _pass="${4}";
  local _authDb="${5:-admin}";
  local _authMechanism="${6:-SCRAM-SHA-256}";
  local _database="${7}";

  if isNotEmpty "${_database}"; then
    _database="-d ${_database}";
  fi

  local -i _rescode;
  local _output;

  if isEmpty "${_user}"; then
    _output="$(mongoimport -h ${_host} ${_database} "${_file}" 2>&1)";
    _rescode=$?;
  else
    _output="$(mongoimport -h ${_host} -u ${_user} -p ${_pass} --authenticationDatabase=${_authDb} --authenticationMechanism=${_authMechanism} ${_database} "${_file}" 2>&1)";
    _rescode=$?;
  fi

  if isFalse ${_rescode}; then
    export ERROR="${_output}";
  fi

  return ${_rescode};
}

# fun: startMongodWithAuthenticationDisabled user group permissionsFolder configFile
# api: public
# txt: Starts mongod with authentication enabled, using given user and group (and ensuring its permissions match the owners of given permissionsFolder parameter).
# opt: user: The owner of the process.
# opt: group: The group of the process.
# opt: permissionsFolder: The folder used to get the permissions from (the user and group will be adapted to match the folder's).
# opt: configFile: The mongod config file.
# txt: Returns 0/TRUE if the process could be started; 1/FALSE otherwise.
# use: startMongodbWithAuthenticationDisabled mongo mongo /var/lib/mongodb /etc/mongod.conf & disown;
function startMongodWithAuthenticationDisabled() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _group="${2}";
  checkNotEmpty group "${_group}" 2;
  local _permissionsFolder="${3}";
  checkNotEmpty permissionsFolder "${_permissionsFolder}" 3;
  local _configFile="${4}";
  checkNotEmpty configFile "${_configFile}" 4;

  checkReq run-as.sh;
  checkReq mongod;

  resolveVerbosity;
  local _verbosity="${RESULT}";

  chmod a+x "${_permissionsFolder}";

  run-as.sh ${_verbosity} -U ${_user} -G ${_group} -- "${_permissionsFolder}" mongod --config "${_configFile}";
  local -i _rescode=$?;

  return ${_rescode};
}

# fun: startMongodWithAuthenticationEnabled user group permissionsFolder configFile authMechanism
# api: public
# txt: Starts mongod with authentication enabled, using given user and group (and ensuring its permissions match the owners of given permissionsFolder parameter).
# opt: user: The owner of the process.
# opt: group: The group of the process.
# opt: permissionsFolder: The folder used to get the permissions from (the user and group will be adapted to match the folder's).
# opt: configFile: The mongod config file.
# opt: authMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the process could be started; 1/FALSE otherwise.
# use: startMongodbWithAuthenticationEnabled mongo mongo /var/lib/mongodb /etc/mongod.conf SCRAM-SHA-256 & disown;
function startMongodWithAuthenticationEnabled() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _group="${2}";
  checkNotEmpty group "${_group}" 2;
  local _permissionsFolder="${3}";
  checkNotEmpty permissionsFolder "${_permissionsFolder}" 3;
  local _configFile="${4}";
  checkNotEmpty configFile "${_configFile}" 4;
  local _authMechanism="${5}";
  checkNotEmpty authMechanism "${_authMechanism}" 5;

  checkReq run-as.sh;
  checkReq mongod;

  resolveVerbosity;
  local _verbosity="${RESULT}";

  chmod a+x "${_permissionsFolder}";

  run-as.sh ${_verbosity} -U ${_user} -G ${_group} -- "${_permissionsFolder}" mongod --config "${_configFile}" --auth --setParameter authenticationMechanisms=${_authMechanism};
  local -i _rescode=$?;

  return ${_rescode};
}

# fun: waitUntilMongodIsRunning timeout checkInterval
# api: public
# txt: Waits until mongod is running.
# opt: timeout: The maximum number of seconds to wait.
# opt: checkInterval: How often to check.
# txt: Returns 0/TRUE if mongod is running; 1/FALSE if it didn't start after the timeout expired.
# use: if waitUntilMongodIsRunning 60 5; then echo "Mongod is running"; fi
function waitUntilMongodIsRunning() {
  local -i _timeout=${1};
  checkNumber timeout "${_timeout}" 1;
  local -i _checkInterval=${2};
  checkNumber checkInterval "${_checkInterval}" 2;

  local -i _rescode=${TRUE};
  local -i _attempts=0;

  while ! isMongodRunning; do
    add ${_attempts} 1;
    _attempts=${RESULT};
    multiply ${_attempts} ${_checkInterval};
    local -i _currentWait=${RESULT};
    if isLessThan ${_timeout} ${_currentWait}; then
      _rescode=${FALSE};
      break;
    fi
    sleep ${_checkInterval};
  done

  return ${_rescode};
}

# fun: checkMongodIsRunning
# api: public
# txt: Checks mongod is not running.
# txt: Returns 0/TRUE if mongod is running; 1/FALSE otherwise.
# use: if checkMongodIsRunning; then echo "mongod is not running"; fi
function checkMongodIsRunning() {
  DW.import process;

  isRunning $(which mongod);
}

# fun: checkMongodIsRunningWithNoAuthentication
# api: public
# txt: Checks mongod is running with no authentication.
# txt: Returns 0/TRUE if mongod is running with no authentication enabled; 1/FALSE otherwise.
# use: if checkMongodIsRunningWithNoAuthentication; then echo "Mongod is not running, or it's running with auth enabled"; fi
function checkMongodIsRunningWithNoAuthentication() {
  local -i _rescode=${FALSE};

  if checkMongodIsRunning; then
    ps -ef | grep --color=none $(which mongod) | grep --color=none -v " --auth " | grep -v grep > /dev/null 2>&1;
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: checkMongodIsNotRunning
# api: public
# txt: Checks mongod is not running.
# txt: Returns 0/TRUE if mongod is not running; 1/FALSE otherwise.
# use: if checkMongodIsNotRunning; then echo "mongod is not running"; fi
function checkMongodIsNotRunning() {
  local -i _rescode;

  checkMongodIsRunning;
  if isTrue $?; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: checkMongoUserCanLogin user password authenticationDb authenticationMechanism
# api: public
# txt: Checks given MongoDB user can login.
# opt: user: The user name.
# opt: password: The password.
# opt: authenticationDb: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if given user can log in; 1/FALSE otherwise.
# use: if checkMongoUserCanLogIn root secret admin SCRAM-SHA-256; then echo "User can log in"; fi
function checkMongoUserCanLogIn() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _authenticationDb="${3}";
  checkNotEmpty authenticationDb "${_authenticationDb}" 3;
  local _authenticationMechanism="${4}";
  checkNotEmpty authenticationMechanism "{_authenticationMechanism}" 4;

  local -i _rescode;

  local _output="$(mongo -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDb}" --authenticationMechanism="${_authenticationMechanism}" --eval "{ ping: 1 }" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: checkMongoRoleExists role user password authenticationDb authenticationMechanism
# api: public
# txt: Checks given MongoDB role exists.
# opt: role: The role.
# opt: user: The user name.
# opt: password: The password.
# opt: authenticationDb: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if given role exists; 1/FALSE otherwise.
# use: if checkMongoRoleExists backup root secret admin SCRAM-SHA-256; then echo "backup role does not exist"; fi
function checkMongoRoleExists() {
  local _role="${1}";
  checkNotEmpty role "${_role}" 1;
  local _user="${2}";
  checkNotEmpty user "${_user}" 2;
  local _password="${3}";
  checkNotEmpty password "${_password}" 3;
  local _authenticationDb="${4}";
  checkNotEmpty authenticationDb "${_authenticationDb}" 4;
  local _authenticationMechanism="${5}";
  checkNotEmpty authenticationMechanism "{_authenticationMechanism}" 5;

  local -i _rescode;

  local _output="$(mongo -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDb}" --authenticationMechanism="${_authenticationMechanism}" "${_authenticationDb}" --eval "db.getRole('${_role}')" 2>&1)";
  # _rescode=$?; # not reliable for some reason.

  if contains "${_output}" "uncaught exception"; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
