# mod: rabbitmq
# api: public
# txt: Functions useful when bootstrapping RabbitMQ servers.
# txt: You might be interested in importing rabbitmq-cli as well, to inject processing of the required environment variables above.

# fun: addUser user password nodename
# api: public
# txt: Adds a new RabbitMQ user.
# opt: user: The username.
# opt: password: The password.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the user was added; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if addUser "admin" "secret" 'rabbit@server'; then
# use:   echo "User admin added successfully";
# use: fi
function addUser() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _password="${2}";
  checkNotEmpty password "${_password}" 2;
  local _nodename="${3}";
  checkNotEmpty nodename "${_nodename}" 3;
  local -i _rescode;
  local _log;

  logTrace -n "Adding ${_user}";
  _log="$(rabbitmqctl -n "${_nodename}" add_user ${_user} "${_password}" 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: addVhost virtualHost nodename
# api: public
# txt: Declares a virtual host.
# opt: virtualHost: The virtual host.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the virtual host gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if ! addVhost "/" 'rabbit@server'; then
# use:   echo "Could not add vhost /";
# use: fi
function addVhost() {
  local _vhost="${1}";
  checkNotEmpty virtualHost "${_vhost}" 1;
  local _nodename="${2}";
  checkNotEmpty nodename "${_nodename}" 2;
  local -i _rescode;
  local _log;

  logTrace -n "Adding virtual host ${_vhost}";

  _log="$(rabbitmqctl -n "${_nodename}" add_vhost "${_vhost}" 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: declareBdbinding source destinationType destination routingKey nodename
# api: public
# txt: Declares a binding.
# opt: source: The source.
# opt: destinationType: The destination type.
# opt: destination: The destination.
# opt: routingKey: The routing key.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the binding gets created successfully; 1/FALSE othervise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if declareBinding "my-exchange" "queue" "my-queue" "#" 'rabbit@server'; then
# use:   echo "binding created successfully";
# use: fi
function declareBinding() {
  local _source="${1}";
  checkNotEmpty source "${_source}" 1;
  local _destinationType="${2}";
  checkNotEmpty destinationType "${_destinationType}" 2;
  local _destination="${3}";
  checkNotEmpty destination "${_destination}" 3;
  local _routingKey="${4}";
  checkNotEmpty routingKey "${_routingKey}" 4;
  local _nodename="${5}";
  checkNotEmpty nodename "${_nodename}" 5;
  local -i _rescode;
  local _log;

  logTrace -n "Declaring binding: source=${_source} destination_type=${_destinationType} destination=${_destination} routing_key=${_routingKey}";
  _log="$(rabbitmqadmin -N "${_nodename}"  -u admin -p ${ADMIN_PASSWORD} declare binding source=${_source} destination_type=${_destinationType} destination=${_destination} routing_key=${_routingKey} 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: declareExchange name type nodename durable internal args*
# api: public
# txt: Declares an exchange.
# opt: name: The exchange name.
# opt: type: The exchange type.
# opt: nodename: The node name.
# opt: durable: Whether the exchange is durable. Optional.
# opt: internal: Whether the exchange is internal. Optional.
# opt: args: Additional arguments. Optional.
# txt: Returns 0/TRUE if the exchange gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if declareExchange "ex" "topic" 'rabbit@server'; then
# use:   echo "ex exchange created successfully";
# use: fi
function declareExchange() {
  local _name="${1}";
  checkNotEmpty name "${_name}" 1;
  local _type="${2}";
  checkNotEmpty type "${_type}" 2;
  local _nodename="${3}";
  checkNotEmpty nodename "${_nodename}" 3;
  local _durable;
  local _internal;
  local _extra;
  local -i _rescode;
  local _log;
  shift;
  shift;
  shift;
  _durable="${1}";

  if ! isEmpty "${_durable}"; then
    shift;
    _internal="${1}";
    if ! isEmpty "${_internal}"; then
      shift;
      _extra="${@}";
    fi
  fi
  local -i _rescode;

  if ! isEmpty "${_durable}"; then
    _durable="durable=${_durable}";
  fi

  if ! isEmpty "${_internal}"; then
    _internal="internal=${_internal}";
  fi

  logTrace -n "Declaring exchange name=${_name} type=${_type} ${_durable} ${_internal} ${_extra}";
  _log="$(rabbitmqadmin -N "${_nodename}"  -u admin -p ${ADMIN_PASSWORD} declare exchange name=${_name} type=${_type} ${_durable} ${_internal} ${_extra} > 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: declareQueue name durable nodename (accessUser accessPassword)?
# api: public
# txt: Declares a queue.
# opt: name: The queue name.
# opt: durable: Whether it's durable or not.
# opt: nodename: The node name.
# opt: accessUser: The access user. Optional.
# opt: accessPassword: The access password. Optional.
# txt: Returns 0/TRUE if the queue is created successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if declareQueue "my-queue" "true" 'rabbit@server' 'admin' 'secret'; then
# use:   echo "Queue my-queue created successfully";
# use: fi
function declareQueue() {
  local _name="${1}";
  checkNotEmpty name "${_name}" 1;
  local _durable="${2}";
  checkNotEmpty durable "${_durable}" 2;
  local _nodename="${3}";
  checkNotEmpty nodename "${_nodename}" 3;
  local _accessUser="${4}";
  local _accessPassword="${5}";
  local -i _rescode;
  local _log;

  local _loginPart;
  if isNotEmpty "${_accessUser}"; then
    _loginPart="-u \"${_accessUser}\" -p \"${_accessPassword}\"";
  fi

  logTrace -n "Declaring queue name=${_name} durable=${_durable}";
  _log="$(rabbitmqadmin -N "${_nodename}" ${_loginPart} declare queue name=${_name} durable=${_durable} 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: deleteUser user nodename
# api: public
# txt: Deletes an user.
# opt: user: The user.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the user gets deleted successfully; 1/FALSE otherwise.
# use: if deleteUser "guest" 'rabbit@server'; then
# use:   echo "guest user deleted successfully";
# use: fi
function deleteUser() {
  local _name="${1}";
  checkNotEmpty user "${_name}" 1;
  local _nodename="${2}";
  checkNotEmpty nodename "${_nodename}" 2;
  local -i _rescode;
  local _log;

  logTrace -n "Deleting user ${_name}";

  _log="$(rabbitmqctl -n ${_nodename} delete_user ${_name} 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: enableRabbitmqManagement nodename
# api: dry-wti
# txt: Enables the plugin-management mode.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the operation succeeds; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if ! enableRabbitmqManagement 'rabbit@server'; then
# use:   echo "Cannot enable plugin management mode";
# use: fi
function enableRabbitmqManagement() {
  local _nodename="${1}";
  checkNotEmpty nodename "${_nodename}" 1;
  local -i _rescode;
  local _log;

  _log="$(rabbitmq-plugins -n ${_nodename} --offline enable rabbitmq_management 2>&1)";
  _rescode=$?;

  if isTrue ${_rescode}; then
    export OUTPUT="${_log}";
  else
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: ensureRabbitmqManagementIsEnabled nodename
# api: public
# txt: Ensures the rabbitmq_management plugin is enabled.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the rabbitmq_management plugin is enabled or was already enabled; 1/FALSE if it could not be enabled for some reason.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if ensureRabbitmqManagementIsEnabled 'rabbit@server'; then
# use:   echo "RabbitMQ management enabled";
# use: fi
function ensureRabbitmqManagementIsEnabled() {
  local _nodename="${1}";
  checkNotEmpty nodename "${_nodename}" 1;
  local -i _rescode;
  local _log;

  _log="$(rabbitmq-plugins -n "${_nodename}" list rabbitmq_management | grep -e '^\[E.\]\srabbitmq_management\s.*')";
  _rescode=$?;

  if isFalse ${_rescode}; then
    _log="$(rabbitmq-plugins -n "${_nodename}" list rabbitmq_management | grep -e '^\[e.\]\srabbitmq_management\s.*')";
    _rescode=$?;
  fi

  if isFalse ${_rescode}; then
    enableRabbitmqManagement "${_nodename}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: isRabbitmqRunning
# api: public
# txt: Checks whether RabbitMQ is running.
# txt: Returns 0/TRUE if it's running; 1/FALSE otherwise.
# use: if ! isRabbitmqRunning; then
# use:   echo "RabbitMQ is not running";
# use: fi
function isRabbitmqRunning() {
  local -i _rescode;

  #  rabbitmqctl status --offline > /dev/null
  exec 6<>/dev/tcp/127.0.0.1/15672;
  _rescode=$?;
  exec 6>&- # close output connection
  exec 6<&- # close input connection

  return ${_rescode};
}
# fun: setPermissions virtualHost user configurePermissions writePermissions readPermissions nodename
# api: public
# txt: Sets RabbitMQ permissions.
# opt: virtualHost: The virtualhost.
# opt: user: The user.
# opt: configurePermissions: The configure permissions.
# opt: writePermissions: The write permissions.
# opt: readPermissions: The read permissions.
# opt: nodename: The nodename.
# txt: Returns 0/TRUE if the permissions were set successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if ! setPermissions / admin ".*" ".*" ".*" 'rabbit@server'; then
# use:   echo "Could not set permissions for admin";
# use: fi
function setPermissions() {
  local _vhost="${1}";
  checkNotEmpty virtualHost "${_vhost}" 1;
  local _user="${2}";
  checkNotEmpty user "${_user}" 2;
  local _configure="${3}";
  checkNotEmpty configurePermissions "${_configure}" 3;
  local _write="${4}";
  checkNotEmpty writePermissions "${_write}" 4;
  local _read="${5}";
  checkNotEmpty readPermissions "${_read}" 5;
  local _nodename="${6}";
  checkNotEmpty nodename "${_nodename}" 6;
  local -i _rescode;
  local _log;

  logTrace -n "Setting permissions: vhost ${_vhost}, user ${_user}, configure ${_configure}, write ${_write}, read ${_read}";
  _log="$(rabbitmqctl -n ${_nodename} set_permissions -p ${_vhost} ${_user} "${_configure}" "${_write}" "${_read}" 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: setPolicy name match body type nodename
# api: public
# txt: Sets a policy.
# opt: name: The policy name.
# opt: match: The match.
# opt: body: The policy body.
# opt: type: The object type: which objects apply.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the policy gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if setPolicy "my-dlx" "^my-ex" '{"dead-letter-exchange":"my-dlx"}' "queues" 'rabbit@server'; then
# use:   echo "Policy created successfully";
# use: fi
function setPolicy() {
  local _name="${1}";
  checkNotEmpty name "${_name}" 1;
  local _match="${2}";
  checkNotEmpty match "${_match}" 2;
  local _body="${3}";
  checkNotEmpty body "${_body}" 3;
  local _objectType="${4}";
  checkNotEmpty type "${_objectType}" 4;
  local _nodename="${5}";
  checkNotEmpty nodename "${_nodename}" 5;
  local -i _rescode;
  local _log;

  logTrace -n "Setting policy  ${_name} ${_match} ${_body} --apply-to ${_objectType}";
  _log="$(rabbitmqctl -n ${_nodename} set_policy "${_name}" "${_match}" "${_body}" --apply-to "${_objectType}" 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: setUserTags nodename user tags+
# api: public
# txt: Sets user tags.
# opt: nodename: The node name.
# opt: user: The user.
# opt: tags: The tags.
# txt: Returns 0/TRUE if the tags were set successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable OUTPUT contains some extra logging; otherwise, the variable ERROR contains more information about the error.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if ! setUserTags admin administrator; then
# use:   echo "Could not set administrator tag for admin user";
# use: fi
function setUserTags() {
  local _nodename="${1}";
  checkNotEmpty nodename "${_nodename}" 1;
  local _user="${2}";
  checkNotEmpty user "${_user}" 2;
  shift;
  shift;
  local _tags="${@}";
  checkNotEmpty tags "${_tags}" 3;
  local -i _rescode;
  local _log;

  logTrace -n "Setting ${_user} tags: ${_tags}";
  _log="$(rabbitmqctl -n ${_nodename} set_user_tags ${_user} ${_tags} 2>&1)";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "done";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "failed";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: getUserTags user nodename (accessUser accessPassword)?
# api: public
# txt: Retrieves the tags of given user.
# opt: user: The user.
# opt: nodename: The node name.
# opt: accessUser: The username used to connect. Optional.
# opt: accessPassword: The password used to connect. Optional.
# txt: Returns 0/TRUE if the tags could be retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the tags; otherwise, the variable ERROR contains some additional error information.
# use: if getUserTags monitoring 'rabbit@server' 'admin' 'secret'; then
# use:   echo "tags: ${RESULT}";
# use: fi
function getUserTags() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _nodename="${2}";
  checkNotEmpty nodename "${_nodename}" 2;
  local _accessUser="${3}";
  local _accessPassword="${4}";

  local -i _rescode;
  local _log;

  if isEmpty "${_accessUser}"; then
    _log="$(rabbitmqadmin -f raw_json -N "${_nodename}" list users | jq '.[] | select(.name == "${_user}") | .tags' | sed 's ^"  g' | sed 's "$  g')";
  else
    _log="$(rabbitmqadmin -f raw_json -N "${_nodename}" -u "${_accessUser}" -p "${_accessPassword}" list users | jq '.[] | select(.name == "${_user}") | .tags' | sed 's ^"  g' | sed 's "$  g')";
  fi
  _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_log}";
  else
    export ERROR="${_log}";
  fi

  return ${_rescode};
}

# fun: addTagToUser user tag nodename (accessUser accessPassword)?
# api: public
# txt: Adds a given tag to a user.
# opt: user: The user.
# opt: tag: The tag.
# opt: nodename: The node name.
# opt: accessUser: The username used to connect. Optional.
# opt: accessPassword: The password used to connect. Optional.
# txt: Returns 0/TRUE if the tag could be added to the user; 1/FALSE otherwise.
# use: if addTagToUser admin administrator 'rabbit@server'; then
# use:   echo "Tag administrator added";
# use: fi
function addTagToUser() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _tag="${2}";
  checkNotEmpty tag "${_tag}" 2;
  local _nodename="${3}";
  checkNotEmpty nodename "${_nodename}" 3;
  local _accessUser="${4}";
  local _accessPassword="${5}";

  local -i _rescode=${FALSE};
  local _log;

  if getUserTags "${_user}" "${_nodename}" "${_accessUser}" "${_accessPassword}"; then
    local _currentTags="${RESULT}";
    # Remove the first occurrence of the tag, if it exists and it's in the first position.
    local _firstMatchRemoved="$(echo "${_currentTags}" | sed 's ^${_tag},  g' )";
    # Remove the last ocurrence of the tag, if it exists and it's in the last position.
    local _lastMatchRemoved="$(echo "${_firstMatchRemoved}" | sed 's ,${_tag}$  g')";
    # Remove an intermediate ocurrence of the tag, if it exists and it's somewhere in between.
    local _tags="$(echo "${_lastMatchRemoved}" | sed 's ,${_tag},  g')";
    if isNotEmpty "${_tags}"; then
      _tags="${_tags},";
    fi
    setUserTags "${_nodename}" "${_user}" "${_tags}${_tag}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: userAlreadyExists user nodename
# api: public
# txt: Checks if given user already exists.
# opt: nodename: The node name.
# txt: Returns 0/TRUE if the user exists; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains some logging information; otherwise, the variable ERROR contains some information about the error.
# use: if userAlreadyExists admin 'rabbit@server'; then
# use:   echo "User admin already exists";
# use: fi
function userAlreadyExists() {
  local _user="${1}";
  checkNotEmpty user "${_user}" 1;
  local _nodename="${2}";
  checkNotEmpty nodename "${_nodename}" 2;
  local -i _rescode;
  local _log;

  logTrace -n "Checking if ${_user} already exists";
  _log="$(rabbitmqctl -n "${_nodename}" list_users 2>&1 | grep --color=none -e "^${_user}\s.*")";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logTraceResult SUCCESS "exists";
    export OUTPUT="${_log}";
  else
    logTraceResult FAILURE "doesn't exist";
    export ERROR="${_log}";
  fi

  return ${_rescode};
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
