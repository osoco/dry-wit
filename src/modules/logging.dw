# mod: logging
# api: public
# txt: Logging functions

# set -o xtrace

# fun: LOGGING.getModuleName
# api: private
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: LOGGING.getModuleName; echo "Module: ${RESULT}";
function LOGGING.getModuleName() {
  export RESULT="LOGGING";
  return ${TRUE};
}

# fun: definedTag tag
# api: public
# txt: Checks whether given tag is defined.
# opt: tag: The tag to check.
# txt: 0/TRUE if the tag is defined; 1/FALSE otherwise.
# use: definedTag SUCCESS
function definedTag() {
  local _tag="${1}";
  checkNotEmpty tag "${_tag}" 1;

  local -i _rescode;

  case "${_tag}" in
    "${SUCCESS}" | "${FAILURE}") _rescode=${TRUE};
                                 ;;
    *) _rescode=${FALSE};
       ;;
  esac

  return ${_rescode};
}

# fun: disableQuietMode
# api: public
# txt: Disables quiet mode.
# txt: Returns 0/TRUE always.
# use: disableQuietMode;
function disableQuietMode() {
  setQuietMode ${FALSE};
}

# fun: enableQuietMode
# api: public
# txt: Enables quiet mode.
# txt: Returns 0/TRUE always.
# use: enableQuietMode;
function enableQuietMode() {
  setQuietMode ${TRUE};
}

# fun: findOutKeyword text
# api: public
# txt: Guesses the type of keyword associated to given text.
# opt: text: The text of the keyword.
# txt: Returns SUCCESS, FAILURE, or UNDEFINED.
# use: findOutKeyword "done";
#      local -i keyword=$?;
function findOutKeyword() {
  local _value="${1}";
  checkNotEmpty text "${_value}" 1;

  local -i _rescode;

  case "${_value}" in
    "${SUCCESS}") _rescode=${SUCCESS};
                  ;;
    "${FAILURE}") _rescode=${FAILURE};
                  ;;
    *) if isSuccessKeyword "${_value}"; then
         _rescode=${SUCCESS};
       elif isFailureKeyword "${_value}"; then
         _rescode=${FAILURE};
       else
         _rescode=${UNDEFINED};
       fi
       ;;
  esac

  return ${_rescode};
}

# fun: getLogCategory
# api: public
# txt: Retrieves the log category.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category.
# use: getLogCategory; echo "Log category: ${RESULT}";
function getLogCategory() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_CATEGORY;
}

# fun: getLogCategoryNamespace
# api: public
# txt: Retrieves the log category namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category namespace.
# use: getLogCategoryNamespace;
#      echo "log category namespace: ${RESULT}"
function getLogCategoryNamespace() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_CATEGORY_NAMESPACE;
}

# fun: LOGGING.getLogDebug
# api: private
# txt: Retrieves the LOG_DEBUG value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_DEBUG.
# use: LOGGING.getLogDebug; local logDebug=${RESULT};
function LOGGING.getLogDebug() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_DEBUG;
}

# fun: isDebugEnabled
# api: public
# txt: Checks whether the debug level is enabled.
# txt: Returns 0/TRUE if debug is allowed; 1/FALSE otherwise.
# use: isDebugEnabled;
function isDebugEnabled() {
  local -i _rescode=${FALSE};

  if isInfoEnabled; then
    LOGGING.getLogDebug;
    _rescode=${RESULT};
  fi

  return ${_rescode};
}

# fun: LOGGING.getSuccessKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the success keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the success keywords.
# use: LOGGING.getSuccessKeywordsVariableName; local -n successKeywords=${RESULT}
function LOGGING.getSuccessKeywordsVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" SUCCESS_KEYWORDS;
}

# fun: LOGGING.getFailureKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the failure keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the failure keywords.
# use: LOGGING.getFailureKeywordsVariableName; local -n failureKeywords=${RESULT}
function LOGGING.getFailureKeywordsVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" FAILURE_KEYWORDS;
}

# fun: LOGGING.getBuiltinSuccessKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the built-in success keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the built-in success keywords.
# use: LOGGING.getBuiltinSuccessKeywordsVariableName; local -n builtinSuccessKeywords=${RESULT}
function LOGGING.getBuiltinSuccessKeywordsVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" BUILTIN_SUCCESS_KEYWORDS;
}

# fun: LOGGING.getBuiltinFailureKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the built-in failure keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the built-in failure keywords.
# use: LOGGING.getBuiltinFailureKeywordsVariableName; local -n builtinFailureKeywords=${RESULT}
function LOGGING.getBuiltinFailureKeywordsVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" BUILTIN_FAILURE_KEYWORDS;
}

# fun: isFailureKeyword keyword
# api: public
# txt: Checks whether given keyword represents a failure.
# opt: keyword: The keyword.
# txt: Returns 0/TRUE if the keyword is considered a failure; 1/FALSE otherwise.
# use: if isFailureKeyword "${keyword}"; then logInfoResult SUCCESS "done"; fi
function isFailureKeyword() {
  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 1;

  local -i _rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";

  LOGGING.getFailureKeywordsVariableName;
  local -n _failureKeywords=${RESULT};

  IFS=$' \t\n';
  for _i in ${_failureKeywords[@]}; do
    IFS="${_oldIFS}";
    if    areEqual "${_i}" "${1}" \
       || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                   "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
      _rescode=${TRUE};
      break;
    fi;
  done
  IFS="${_oldIFS}";

  if isFalse ${_rescode}; then
    LOGGING.getBuiltinFailureKeywordsVariableName;
    local -n _builtinFailureKeywords=${RESULT};

    for _i in ${_builtinFailureKeywords[@]}; do
      IFS="${_oldIFS}";
      if   areEqual "${_i}" "${1}" \
        || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                    "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        _rescode=${TRUE};
        break;
      fi;
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: LOGGING.getLogInfo
# api: private
# txt: Retrieves the LOG_INFO value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_INFO.
# use: LOGGING.getLogInfo; local logInfo=${RESULT};
function LOGGING.getLogInfo() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_INFO;
}

# fun: isInfoEnabled
# api: public
# txt: Checks whether the "info" level is enabled.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isInfoEnabled; then ...; fi
function isInfoEnabled() {
  local -i _rescode;

  if isQuietMode; then
    _rescode=${FALSE};
  else
    LOGGING.getLogInfo;
    _rescode=${RESULT};
  fi

  return ${_rescode};
}

# fun: isLowerThanInfoEnabled
# api: public
# txt: Checks whether the enabled log level is lower than "info".
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isLowerThanInfoEnabled; then ...; fi
function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

# fun: LOGGING.getLogQuiet
# api: private
# txt: Retrieves the LOG_QUIET value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_QUIET.
# use: LOGGING.getLogQuiet; local logQuiet=${RESULT};
function LOGGING.getLogQuiet() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_QUIET;
}

# fun: isQuietMode
# api: public
# txt: Retrieves whether the quiet mode is on or off.
# txt: Returns 0/TRUE if the mode is enabled; 1/FALSE otherwise.
# use: if isQuietMode; then ...; fi
function isQuietMode() {
  local -i _rescode;

  LOGGING.getLogQuiet;
  _rescode=${RESULT};

  return ${_rescode};
}

# fun: isSuccessKeyword keyword
# api: public
# txt: Checks whether given keyword represents a success.
# opt: keyword: The keyword.
# txt: Returns 0/TRUE if the keyword is considered a success; 1/FALSE otherwise.
# use: if isSuccessKeyword "${keyword}"; then logInfoResult SUCCESS "done"; fi
function isSuccessKeyword() {
  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 1;
  local -i _rescode=${FALSE};
  local _i;
  local _oldIFS="${IFS}";

  LOGGING.getSuccessKeywordsVariableName;
  local -n _successKeywords="${RESULT}";

  IFS=$' \t\n';
  if    isNotEmpty "${_successKeywords}" \
     && isNotEmpty "${_successKeywords[@]}"; then
    for _i in ${_successKeywords[@]}; do
      IFS="${_oldIFS}";
      if    areEqual "${_i}" "${_keyword}" \
         || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                     "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        _rescode=${TRUE};
        break;
      fi;
    done
    IFS="${_oldIFS}";
  fi

  LOGGING.getBuiltinSuccessKeywordsVariableName;
  local -n _builtinSuccessKeywords=${RESULT};

  if    isFalse ${_rescode} \
     && isNotEmpty "${_builtinSuccessKeywords}" \
     && isNotEmpty "${_builtinSuccessKeywords[@]}"; then
    for _i in ${_builtinSuccessKeywords[@]}; do
      IFS="${_oldIFS}";
      if    areEqual "${_i}" "${1}" \
          || areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
                      "$(echo \"${_i}\"       | tr [:upper:] [:lower:] 2> /dev/null)"; then
        _rescode=${TRUE};
        break;
      fi;
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: LOGGING.getLogTrace
# api: private
# txt: Retrieves the LOG_TRACE value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_TRACE.
# use: LOGGING.getLogTrace; local logTrace=${RESULT};
function LOGGING.getLogTrace() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_TRACE;
}

# fun: isTraceEnabled
# api: public
# txt: Checks whether trace is enabled.
# txt: Returns 0/TRUE if trace is enabled; 1/FALSE otherwise.
# use: isTraceEnabled;
function isTraceEnabled() {
  local -i _rescode=${FALSE};

  if isDebugEnabled; then
    LOGGING.getLogTrace;
    _rescode=${RESULT};
  fi

  return ${_rescode};
}

# fun: log message
# api: public
# txt: Logs a message as "info".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: log "Operation in progress";
function log() {
  checkNotEmpty message "${1}" 1;
  logInfo "$@";
}

# fun: logDebug message
# api: public
# txt: Logs given message under the "debug" level.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logDebug "Operation in progress";
function logDebug() {
  if isDebugEnabled; then
    checkNotEmpty message "${1}" 1;
    LOGGING.logStuff DEBUG "$@";
  fi
}

# fun: logDebugFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logDebugFromStdin <<<"Operation in progress";
function logDebugFromStdin() {
  if isDebugEnabled; then
    local _line;
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff DEBUG "${_line}";
      fi
    done
  fi
}

# fun: logDebugFile file
# api: public
# txt: Logs the contents of given file, under the "debug" level.
# opt: file: The file to log.
# txt: Returns 0/TRUE always.
# use: logDebugFile '/tmp/my-log.txt';
function logDebugFile() {
  local _file;
  local _line;
  if isDebugEnabled; then
    _file="${1}";
    checkNotEmpty file "${_file}" 1;
    cat "${_file}" | while IFS='' read -r line; do LOGGING.logStuff DEBUG "${line}"; done
  fi
}

# fun: logDebugFileContents file
# api: public
# txt: Logs the contents of a file, using the DEBUG level.
# opt: file: The file.
# txt: Returns 0/TRUE always.
# use: logDebugFileContents /tmp/my-file.log
function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

# fun: logDebugResult SUCCESS|FAILURE message
# api: public
# txt: Logs given outcome under the "debug" level.
# opt: SUCCESS|FAILURE: The keyword.
# opt: message: The outcome to log.
# txt: Returns 0/TRUE always.
# use: logDebugResult SUCCESS "done";
function logDebugResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isDebugEnabled; then
    checkNotEmpty "SUCCESS|FAILURE" "${_outcome}" 1;
    LOGGING.checkSuccessOrFailure "${_outcome}" 1;
    checkNotEmpty message "${_message}" 2;
    LOGGING.logStuffResult DEBUG "${_outcome}" "${_message}";
  fi
}

# fun: logFile file
# api: public
# txt: Logs the contents of a file, as "info".
# opt: file: The file with the log messages.
# txt: Returns 0/TRUE always.
# use: logFile /tmp/my-log.txt;
function logFile() {
  local _file="${1}";
  checkNotEmpty file "${_file}" 1;
  local line;
  cat "${_file}" | while IFS='' read -r line; do LOGGING.logStuff INFO "${line}"; done
}

# fun: LOGGING.getLogOutcomeTokensVariableName
# api: private
# txt: Retrieves the name of the variable containing the log outcome tokens.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the log outcome tokens.
# use: LOGGING.getLogOutcomeTokensVariableName; local -n logOutputTokens=${RESULT}
function LOGGING.getLogOutcomeTokensVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_TOKENS;
}

# fun: LOGGING.getLogOutcomeSeparator
# api: private
# txt: Retrieves the log outcome separator.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: LOGGING.getLogOutcomeSeparator; local logOutputSeparator="${RESULT}"
function LOGGING.getLogOutcomeSeparator() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_OUTCOME_SEPARATOR;
}

# fun: LOGGING.alignRight message outcome
# api: private
# txt: Writes spaces until the next message to print is aligned to the right.
# opt: message: The log-line message.
# opt: outcome: The log outcome message.
# txt: Returns 0/TRUE always.
# use: LOGGING.alignRight "Finishing work" "done";
function LOGGING.alignRight() {
  local _logLineMessage="${1}";
  checkNotEmpty message "${_logLineMessage}" 1;
  local _outcome="${2}";
  checkNotEmpty "outcome" "${_outcome}" 2;
  local _logMessage;

  local -i _termWidth;
  local -i _index;
  local -i _offset=0;
  local -i _end;
  local _allowsColors;
  local _token;

  LOGGING.processLogOutcomeTokens "${_outcome}";

  LOGGING.getLogOutcomeTokensVariableName;
  local -n _logOutcomeTokens=${RESULT};

  LOGGING.getLogOutcomeSeparator;
  local _logOutcomeSeparator="${RESULT}";

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _token in "${_logOutcomeTokens[@]}"; do
    _logMessage="${_logMessage}${_token}";
  done
  IFS="${_oldIFS}";

  getTermWidth;
  if isTrue $?; then
    _termWidth=${RESULT};
    if [ ${_termWidth} -le 0 ]; then
      exitWithErrorCode POSTCONDITION_NOT_SATISFIED "getTermWidth() must not return successfully providing 0 as output";
    fi
    _index=0;
    allowsColors;
    _allowsColors=$?;
    if isTrue ${_allowsColors}; then
      _offset=$((_offset));
    fi
    _end=$((${_offset}+${_termWidth}-${#_logLineMessage}%${_termWidth}-${#_logMessage}-1));
    while [ $((_end)) -lt 0 ]; do
      echo "";
      _end=$((-${_end}+${_offset}+${_termWidth}-${#_logMessage}));
    done
    while [ $((${_end}-${_index}+1)) != 0 ]; do
      _index=$((${_index}+1));
      echo -n "${_logOutcomeSeparator}";
    done
  fi
}

# fun: LOGGING.closeLogLine
# api: private
# txt: Closes the log line.
# txt: Returns 0/TRUE always.
# use: LOGGING.closeLogLine;
function LOGGING.closeLogLine() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_LINE_OPEN ${FALSE};
}

# fun: LOGGING.getLogPrefixTokensVariableName
# api: private
# txt: Retrieves the name of the variable containing the log prefix tokens.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable containing the log prefix tokens.
# use: LOGGING.getLogPrefixTokensVariableName; local -n logPrefixTokens=${RESULT};
function LOGGING.getLogPrefixTokensVariableName() {
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";

  DW.getGlobalVariableName "${_moduleName}" LOG_PREFIX_TOKENS;
}

# fun: LOGGING.getLogPrefixColorsVariableName
# api: private
# txt: Retrieves the name of the variable containing the log prefix colors.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable containing the log prefix colors.
# use: LOGGING.getLogPrefixColorsVariableName; local -n logPrefixColors=${RESULT};
function LOGGING.getLogPrefixColorsVariableName() {
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";

  DW.getGlobalVariableName "${_moduleName}" LOG_PREFIX_COLORS;
}

# fun: LOGGING.echoColorAwareLogPrefix category TRUE|FALSE TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Prints the log prefix, for color terminals.
# opt: category: The log category.
# opt: TRUE|FALSE: ${TRUE} if using colors; ${FALSE} otherwise.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoColorAwareLogPrefix "cat" ${TRUE} DEBUG
function LOGGING.echoColorAwareLogPrefix() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  local -i _allowsColors=${2};
  checkNotEmpty "TRUE|FALSE" "${_allowsColors}" 2;
  local _level="${3}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 3;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 3;

  local _aux;
  local _colors;
  local -i _i=0;

  LOGGING.processLogPrefixTokens "${_category}" "${_level}";

  LOGGING.getLogPrefixTokensVariableName;
  local -n _logPrefixTokens="${RESULT}";

  LOGGING.getLogPrefixColorsVariableName;
  local -n _logPrefixColors="${RESULT}";

  local _oldIFS="${IFS}";
  IFS=$'\t\n';
  _i=0;
  for _aux in ${_logPrefixTokens[@]}; do
    IFS="${_oldIFS}";
    if isTrue ${_allowsColors}; then
      echoInColor -n "${_logPrefixColors[${_i}]}" "${_aux}";
    else
      echo -n "${_aux}";
    fi
    LOGGING.logToFiles "${_aux}";
    _i=$((_i+1));
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
  echo -n " ";
  LOGGING.logToFiles " ";
}

# fun: LOGGING.getLogOutcomeTokensVariableName
# api: private
# txt: Retrieves the name of the variable containing the log outcome tokens.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the variable name containing the log outcome tokens.
# use: LOGGING.getLogOutcomeTokensVariableName; local -n outcomeTokens=${RESULT};
function LOGGING.getLogOutcomeTokensVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_TOKENS;
}

# fun: LOGGING.getLogOutcomeColorsVariableName
# api: private
# txt: Retrieves the name of the variable containing the log outcome colors.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the variable name containing the log outcome colors.
# use: LOGGING.getLogOutcomeColorsVariableName; local -n outcomeColors=${RESULT};
function LOGGING.getLogOutcomeColorsVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_COLORS;
}

# fun: LOGGING.echoLogOutcome TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|IN_PROGRESS text
# api: private
# txt: Prints the log outcome.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcome() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 2;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;
  shift;
  local _text="${@}";
  checkNotEmpty text "${_text}" 3;

  local -i _len;
  local -i _allowsColors;
  local _colors;
  local _inProgressMessage;
  local _logPrefix;
  local -i _i;

  LOGGING.processLogOutcomeTokens "${_text}";

  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    LOGGING.processLogOutcomeColors ${_keyword};
  fi

  LOGGING.peekLog;
  _inProgressMessage="${RESULT}";
  LOGGING.peekLogCategory;
  _category="${RESULT}";
  if isEmpty "${_category}"; then
    exitWithErrorCode POSTCONDITION_NOT_SATISFIED "_peekLogCaterory must not return an empty string";
  fi
  LOGGING.peekLogLevel;
  _level="${RESULT}";
  LOGGING.retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  LOGGING.alignRight "${_logPrefix}${_inProgressMessage}" "${_text}";

  LOGGING.getLogOutcomeTokensVariableName;
  local -n _logOutcomeTokens=${RESULT};

  LOGGING.getLogOutcomeColorsVariableName;
  local -n _logOutcomeColors=${RESULT};

  _len=$((${#_logOutcomeTokens[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    IFS="${_oldIFS}";
    if isTrue ${_allowsColors}; then
      evalConstant "${_logOutcomeColors[${_i}]}";
      local _outcomeColor="${RESULT}";
      echoInColor -n "${_outcomeColor}" "${_logOutcomeTokens[${_i}]}";
    else
      echo -n "${_logOutcomeTokens[${_i}]}";
    fi
    LOGGING.logToFiles "${_logOutcomeTokens[${_i}]}";
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
}

# fun: LOGGING.getLogNestedIndentation
# api: private
# txt: Retrieves the indentation used when logging nested tasks.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the nested indentation.
# use: LOGGING.getLogNestedIndentation; echo "indentation: ${RESULT}";
function LOGGING.getLogNestedIndentation() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_NESTED_INDENTATION;
}

# fun: LOGGING.echoLogOutcomeNested TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|IN_PROGRESS text
# api: private
# txt: Prints the log outcome, used when nesting log calls.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcomeNested() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _keyword="${1}";
  checkNotEmpty "SUCCESS|FAILURE|IN_PROGRESS" "${_keyword}" 2;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;
  shift;
  local _text="${@}";
  checkNotEmpty text "${_text}" 3;

  local _inProgressMessage;
  local _alreadyInProgressMessage;
  local _category;
  local _alreadyInProgressCategory;
  local _indentation;
  local -i _i;
  LOGGING.popLog;
  _inProgressMessage="${RESULT}";
  LOGGING.popLogCategory;
  _category="${RESULT}";
  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  LOGGING.getLogNestedIndentation;
  local -n _logNestedIndentation=${RESULT};

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 1 ${_nestedTasks}); do
    IFS="${_oldIFS}";
    _indentation="${_indentation}${_logNestedIndentation}";
  done
  IFS="${_oldIFS}";

  LOGGING.pushLog "${_indentation}${_inProgressMessage}";
  LOGGING.pushLogCategory "${_category}";
}

# fun: LOGGING.echoLogPrefix category TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Prints the log prefix.
# opt: category: The log category.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogPrefix "cat" DEBUG;
function LOGGING.echoLogPrefix() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  local _level="${2}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 2;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 2;
  local _allowsColors;
  allowsColors;
  _allowsColors=$?;
  LOGGING.echoColorAwareLogPrefix "${_category}" ${_allowsColors} "${_level}";
}

# fun: LOGGING.getLastLog
# api: private
# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the last log message.
# use: LOGGING.getLastLog; echo "Last log: ${RESULT}";
function LOGGING.getLastLog() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LAST_LOG;
}

# fun: isLogLineOpen
# api: public
# txt: Checks whether the log line is currently opened.
# txt: Returns 0/TRUE if it's open; 1/FALSE otherwise.
# use: if isLogLineOpen; then ...; fi
function isLogLineOpen() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_LINE_OPEN;
  local _open=${RESULT};
  local -i _rescode=${FALSE};
  if isTrue ${_open}; then
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: LOGGING.logCompleted TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompleted INFO SUCCESS "done";
function LOGGING.logCompleted() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _keyword="${1}";
  checkNotEmpty "SUCCESS|FAILURE|IN_PROGRESS" "${_keyword}" 2;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;
  shift;
  local _text="${@}";
  checkNotEmpty text "${_text}" 3;

  local -i nestedTasks;

  LOGGING.setLastLogLevel "${_level}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 1 ]; then
    LOGGING.logCompletedNested "${_level}" "${_keyword}" "${_text}";
  else
    LOGGING.logCompletedNoNested "${_level}" "${_keyword}" "${_text}";
  fi
}

# fun: LOGGING.getDefaultLogResumingTaskColor
# api: private
# txt: Retrieves the default color used when logging a resuming task.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the text.
# use: LOGGING.getDefaultLogResumingTaskColor; echo "Default log resuming task color: ${RESULT}";
function LOGGING.getDefaultLogResumingTaskColor() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_RESUMING_TASK_COLOR;
}

# fun: LOGGING.logCompletedNested TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task, when there're nested tasks.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNested INFO SUCCESS "done";
function LOGGING.logCompletedNested() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _keyword="${1}";
  checkNotEmpty "SUCCESS|FAILURE|IN_PROGRESS" "${_keyword}" 2;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;
  shift
  local _message="$@";
  checkNotEmpty outcome "${_message}" 3;

  local _nestedTask;
  local _nestedTaskCategory;
  local _logPrefix;
  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_message}";
  echo;
  LOGGING.popLogCategory;
  LOGGING.peekLogCategory;
  _nestedTaskCategory="${RESULT}";
  LOGGING.popLogLevel;
  LOGGING.peekLogLevel;
  _nestedTaskLevel="${RESULT}";
  LOGGING.popLog;
  LOGGING.peekLog;
  _nestedTask="${RESULT}";
  LOGGING.echoLogPrefix "${_nestedTaskCategory}" "${_nestedTaskLevel}";
  LOGGING.getDefaultLogResumingTaskColor;
  local _defaultLogResumingTaskColor="${RESULT}";
  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_nestedTask}" "" "${_defaultLogResumingTaskColor}";
  LOGGING.logToFiles "-${_nestedTask}-";
  LOGGING.logToFilesAnEmptyLine;
}

# fun: LOGGING.checkTraceDebugInfoWarnOrError TRACE|DEBUG|INFO|WARN|ERROR index
# api: private
# txt: Checks whether given parameter is either TRACE, DEBUG, INFO, WARN or ERROR.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: index: The parameter index.
# txt: Returns 0/TRUE always, but exits if the condition is not met.
# use: LOGGING.checkTraceDebugInfoWarnOrError logLevel "${logLevel}" 1;
function LOGGING.checkTraceDebugInfoWarnOrError() {
  local _logLevel="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_logLevel}" 1;
  local _index="${2}";
  checkNotEmpty index "${_index}" 2;

  CHECK.checkOneOf 2 "TRACE|DEBUG|INFO|WARN|ERROR" "${_logLevel}" "TRACE DEBUG INFO WARN ERROR" "${_index}";
}

# fun: LOGGING.checkSuccessFailureOrInProgress keyword index
# api: private
# txt: Checks whether given parameter is either SUCCESS, FAILURE or IN_PROGRESS.
# opt: keyword: The keyword.
# opt: index: The parameter index.
# txt: Returns 0/TRUE always, but exits if the condition is not met.
# use: LOGGING.checkSuccessFailureOrInProgress keyword "${keyword}" 1;
function LOGGING.checkSuccessFailureOrInProgress() {
  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 1;
  local _index="${2}";
  checkNotEmpty index "${_index}" 2;

  CHECK.checkOneOf 2 "SUCCESS|FAILURE|IN_PROGRESS" "${_keyword}" "SUCCESS FAILURE IN_PROGRESS" "${_index}";
}

# fun: LOGGING.checkSuccessOrFailure keyword index
# api: private
# txt: Checks whether given parameter is either SUCCESS or FAILURE.
# opt: keyword: The keyword.
# opt: index: The parameter index.
# txt: Returns 0/TRUE always, but exits if the condition is not met.
# use: LOGGING.checkSuccessOrFailure keyword "${keyword}" 1;
function LOGGING.checkSuccessOrFailure() {
  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 1;
  local _index="${2}";
  checkNotEmpty index "${_index}" 2;

  CHECK.checkOneOf 2 "SUCCESS|FAILURE" "${_keyword}" "SUCCESS FAILURE" "${_index}";
}

# fun: LOGGING.checkSuccessOrFailure paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either SUCCESS or FAILURE.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: LOGGING.checkSuccessOrFailure "${successOrFailure}" 1 # -> throws an error if the first (1) parameter ("paramValue") is neither SUCCESS or FAILURE.
function LOGGING.checkSuccessOrFailure() {
  local _value="${1}";
  checkNotEmpty paramValue "${_value}" 1;
  local _index="${2}";
  checkNotEmpty paramIndex "${_index}" 2;

  CHECK.checkOneOf 1 "SUCCESS|FAILURE" "${_value}" "SUCCESS FAILURE" "${_index}";
}

# fun: LOGGING.checkSuccessFailureOrInProgress paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either SUCCESS, FAILURE or IN_PROGRESS.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: LOGGING.checkSuccessFailureOrInProgress "${successFailureOrInProgress}" 1 # -> throws an error if the first (1) parameter ("paramValue") is neither SUCCESS, nor FAILURE, nor IN_PROGRESS.
function LOGGING.checkSuccessFailureOnInProgress() {
  local _value="${1}";
  checkNotEmpty paramValue "${_value}" 1;
  local _index="${2}";
  checkNotEmpty paramIndex "${_index}" 2;

  CHECK.checkOneOf 1 "SUCCESS|FAILURE|IN_PROGRESS" "${_value}" "SUCCESS FAILURE IN_PROGRESS" "${_index}";
}

# fun: LOGGING.logCompletedNestedNoPop TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task, when there're nested tasks.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNested SUCCESS "done";
function LOGGING.logCompletedNestedNoPop() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _keyword="${1}";
  checkNotEmpty "SUCCESS|FAILURE|IN_PROGRESS" "${_keyword}" 2;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;
  shift;
  local _message="$@";
  checkNotEmpty message "${_message}" 3;

  LOGGING.echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}";
}

# fun: LOGGING.logCompletedNoNested TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNoNested INFO SUCCESS "done";
function LOGGING.logCompletedNoNested() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;

  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 2;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;
  shift;

  local _text="${@}";
  checkNotEmpty outcome "${_text}" 3;

  LOGGING.echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  LOGGING.popLog;
  LOGGING.popLogCategory;
  LOGGING.popLogLevel;
  echo;
  LOGGING.logToFilesAnEmptyLine;
}

# fun: LOGGING.logInProgress TRACE|DEBUG|INFO|WARN|ERROR message
# api: private
# txt: Prints a log message, indicating some uncompleted task.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logInProgress INFO "Calculating ...";
function LOGGING.logInProgress() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;

  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;

  local -i nestedTasks;
  local _category;
  LOGGING.retrieveLogNamespace;
  _category="${RESULT}";

  LOGGING.setLastLogLevel "${_level}";
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 0 ]; then
    LOGGING.logInProgressNested "${_category}" "${_level}" "${_message}";
  else
    LOGGING.logInProgressNoNested "${_category}" "${_level}" "${_message}";
  fi
}

# fun: LOGGING.getNestedTaskInProgress
# api: private
# txt: Retrieves the text used to represent a nested task is in progress.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the text.
# use: LOGGING.getNestedTaskInProgress; echo "Nested task in progress: ${RESULT}";
function LOGGING.getNestedTaskInProgress() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" NESTED_TASK_IN_PROGRESS;
}

# fun: LOGGING.logInProgressNested category TRACE|DEBUG|INFO|WARN|ERROR message
# api: private
# txt: Prints a log message, indicating some uncompleted task, when there're nested tasks.
# opt: category: The category.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logInProgressNested "cat" DEBUG "Calculating ...";
function LOGGING.logInProgressNested() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  shift;
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 2;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty message "${_message}" 3;

  local _logPrefix;
  LOGGING.pushLog "${_message}";
  LOGGING.pushLogCategory "${_category}";
  LOGGING.pushLogLevel "${_level}";
  LOGGING.getNestedTaskInProgress;
  local _nestedTaskInProgress="${RESULT}";
  LOGGING.logCompletedNestedNoPop "${_level}" IN_PROGRESS "${_nestedTaskInProgress}";
  echo;
  LOGGING.logToFilesAnEmptyLine;

  LOGGING.retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  LOGGING.echoLogPrefix "${_category}" "${_level}";
  LOGGING.peekLog;
  _actualMessage="${RESULT}";
  LOGGING.getDefaultLogPrefixColor;
  local _defaultLogPrefixColor="${RESULT}";
  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_actualMessage}" "" "${_defaultLogPrefixColor}";
  LOGGING.logToFiles "${_actualMessage}";
  LOGGING.logToFilesAnEmptyLine;
}

# fun: LOGGING.getDefaultLogPrefixColor
# api: private
# txt: Retrieves the log prefix color by default.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the log prefix color by default.
# use: LOGGING.getDefaultLogPrefixColor; echo "default log prefix color: ${RESULT}";
function LOGGING.getDefaultLogPrefixColor() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_PREFIX_COLOR;
}

# fun: LOGGING.logInProgressNoNested category TRACE|DEBUG|INFO|WARN|ERROR message
# api: private
# txt: Prints a log message, indicating some uncompleted task, when there're no nested tasks.
# opt: category: The log category.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logProgressNoNested "cat" INFO "Calculating ...";
function LOGGING.logInProgressNoNested() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  shift;
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 2;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 2;
  shift;

  local _message="$@";
  checkNotEmpty message "${_message}" 3;
  local _logPrefix;

  _logPrefix="${RESULT}";
  LOGGING.pushLogCategory "${_category}";
  LOGGING.pushLog "${_message}";
  LOGGING.pushLogLevel "${_level}";
  LOGGING.echoLogPrefix "${_category}" "${_level}";
  LOGGING.getDefaultLogPrefixColor;
  local _defaultLogPrefixColor="${RESULT}";
  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_message}" "" "${_defaultLogPrefixColor}";
  LOGGING.logToFiles "${_message}";
  LOGGING.logToFilesAnEmptyLine;
}

# fun: LOGGING.logMessage TRACE|DEBUG|INFO|WARN|ERROR message
# api: private
# txt: Prints a log message.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logMessage INFO "A message to log";
function LOGGING.logMessage() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _message="$@";
  checkNotEmpty "message" "${_message}" 2;

  LOGGING.logInProgress "${_level}" "${_message}";
  echo;
  LOGGING.logToFilesAnEmptyLine;
}

# fun: LOGGING.logStuff TRACE|DEBUG|INFO|WARN|ERROR [-n]? message
# api: private
# txt: Main logging logic.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: -n: Whether to use a new line character at the end or not.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: LOGGING.logStuff INFO -n "Operation in progress";
function LOGGING.logStuff() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _minusN="${1}";
  if [ "-n" == "${_minusN}" ]; then
    shift;
  fi
  LOGGING.setLastLog "${@}";
  LOGGING.setLastLogLevel "${_level}";

  if ! isEmpty "$@"; then
    LOGGING.logInProgress "${_level}" "$@";
  fi

  if [ "-n" != "${_minusN}" ]; then
    echo;
    LOGGING.logToFilesAnEmptyLine;
    LOGGING.popLog;
    LOGGING.popLogCategory;
  fi
}

# fun: LOGGING.setLastLogLevel TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Annotates the level of the last logged message.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.setLastLogLevel INFO;
function LOGGING.setLastLogLevel() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;

  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LAST_LOG_LEVEL "${_level}";
}

# fun: getLastLogLevel
# txt: Retrieves the level of the last logged message.
# txt: Returns 0/TRUE always.
# txt: RESULT contains the log level.
# use: getLastLogLevel; echo "Last log level: ${RESULT}";
function getLastLogLevel() {
  local _result;
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LAST_LOG_LEVEL;
  _result="${RESULT}";
  if isEmpty "${_result}"; then
    LOGGING.peekLogLevel;
  fi
}

# fun: LOGGING.logStuffResult TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE message
# api: private
# txt: Logs the outcome of an operation.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logStuffResult INFO SUCCESS "done";
function LOGGING.logStuffResult() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  local _outcome="${2}";
  checkNotEmpty outcome "${_outcome}" 2;
  LOGGING.checkSuccessOrFailure "${_outcome}" 2;
  shift;
  shift;
  checkNotEmpty "text" "${@}" 3;

  local -i _nestedTasks;
  LOGGING.numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if isZero ${_nestedTasks}; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "No ongoing process to print the outcome for. Review ${FUNCNAME[2]}";
  fi
  LOGGING.logCompleted "${_level}" "${_outcome}" "$@";
}

# fun: LOGGING.getLogStackVariableName
# api: private
# txt: Retrieves the name of the variable containing the log stack.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable containing the log stack.
# use: LOGGING.getLogStackVariableName; local -n logStack=${RESULT}
function LOGGING.getLogStackVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
}

# fun: LOGGING.numberOfNestedInProgressTasks
# api: private
# txt: Retrieves the number of "in-progress" tasks pending.
# txt: Returns such count.
# use: LOGGING.numberOfNestedInProgressTasks; local count=$?;
function LOGGING.numberOfNestedInProgressTasks() {
  local -i _rescode;

  LOGGING.getLogStackVariableName;
  local -n _logStack=${RESULT};

  _rescode=${#_logStack[@]};

  return ${_rescode};
}

# fun: LOGGING.openLogLine
# api: private
# txt: Opens the log line.
# txt: Returns 0/TRUE always.
# use: LOGGING.openLogLine;
function LOGGING.openLogLine() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_LINE_OPEN ${TRUE};
}

# fun: LOGGING.peekLog
# api: private
# txt: Peeks given message from top of the log stack.
# txt: Returns 0/TRUE if the stack contains at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the message.
# use: if LOGGING.peekLog; then echo "Last log: ${RESULT}"; fi
function LOGGING.peekLog() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
  local -n _logStack=${RESULT};

  local -i _len=${#_logStack[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logStack[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.peekLogCategory
# api: private
# txt: Peeks given category from the log category stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the category.
# use: if LOGGING.peekLogCategory; then echo "Last log category: ${RESULT}"; fi
function LOGGING.peekLogCategory() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_CATEGORY_STACK;
  local -n _logCategoryStack=${RESULT};

  local -i _len=${#_logCategoryStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logCategoryStack[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.peekLogLevel
# api: private
# txt: Peeks given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the level.
# use: if LOGGING.peekLogLevel; then echo "Last log level: ${RESULT}"; fi
function LOGGING.peekLogLevel() {
  local -i _rescode;
  local _result="";

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK;
  local -n _logLevelStack=${RESULT};

  local -i _len=${#_logLevelStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logLevelStack[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.popLog
# api: private
# txt: Pops given message from the log stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped message.
# use: if LOGGING.popLog; then echo "Last log: ${RESULT}"; fi
function LOGGING.popLog() {
  local -i _rescode;
  local _result="";

  LOGGING.getLogStackVariableName;
  local -n _logStack=${RESULT};

  local -i _len=${#_logStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_logStack[${_newLen}]}";
    LOGGING.setLastLog "${_result}";
    eval "unset _logStack[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: LOGGING.popLogCategory
# api: private
# txt: Pops given category from the log category stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped category.
# use: if LOGGING.popLogCategory; then echo "Last log category: ${RESULT}"; fi
function LOGGING.popLogCategory() {
  local -i _rescode;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_CATEGORY_STACK;
  local -n _logCategoryStack=${RESULT};

  local -i _len=${#_logCategoryStack[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_logCategoryStack[${_newLen}]}";
    eval "unset _logCategoryStack[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: LOGGING.popLogLevel
# api: private
# txt: Pops given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped level.
# use: if LOGGING.popLogLevel; then echo "Last log level: ${RESULT}"; fi
function LOGGING.popLogLevel() {
  local -i _rescode;
  local -i _newLen;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK;
  local -n _logLevelStack=${RESULT};
  local -i _len=${#_logLevelStack[@]};

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_logLevelStack[${_newLen}]}";
    eval "unset _logLevelStack[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: LOGGING.pushLog message
# api: private
# txt: Pushes given message to the log stack.
# opt: message: The message to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLog "Operation in progress";
function LOGGING.pushLog() {
  checkNotEmpty message "$*" 1;
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_STACK;
  local -n _logStack=${RESULT};
  _logStack[${#_logStack[@]}]="$*";
}

# fun: LOGGING.pushLogCategory category
# api: private
# txt: Pushes given category to the log category stack.
# opt: category: The category to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLogCategory "sending-data";
function LOGGING.pushLogCategory() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_CATEGORY_STACK;
  local -n _logCategoryStack=${RESULT};
  _logCategoryStack[${#_logCategoryStack[@]}]="$*";
}

# fun: LOGGING.pushLogLevel TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Pushes given level to the log level stack.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The level to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLogLevel INFO
function LOGGING.pushLogLevel() {
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${1}" 1;
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK;
  local -n _logLevelStack=${RESULT};
  _logLevelStack[${#_logLevelStack[@]}]="$*";
}

# fun: LOGGING.retrieveCategoryPositionInLogPrefix
# api: private
# txt: Retrieves the position of the category in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the category position.
# use: LOGGING.retrieveCategoryPositionInLogPrefix; echo "category -> ${RESULT}";
function LOGGING.retrieveCategoryPositionInLogPrefix() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_CATEGORY_POSITION;
}

# fun: LOGGING.retrieveKeywordColor SUCCESS|FAILURE|IN_PROGRESS defaultColor
# api: private
# txt: Retrieves the color for a given keyword.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# opt: defaultColor: The default color. Optional.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the associated color.
# use: LOGGING.retrieveKeywordColor SUCCESS GREEN; echo "Color -> ${RESULT}";
function LOGGING.retrieveKeywordColor() {
  local _keyword="${1}";
  checkNotEmpty keyword "${_keyword}" 1;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 2;

  getNoColor;
  local _noColor="${RESULT}";
  local _defaultColor="${2:-${_noColor}}";

  local _result;

  getSuccessColor;
  local _successColor="${RESULT}";
  getFailureColor;
  local _failureColor="${RESULT}";
  getInProgressColor;
  local _inProgressColor="${RESULT}";

  case ${_keyword} in
    SUCCESS | "${SUCCESS}") _result="${_successColor}";
                            ;;
    FAILURE | "${FAILURE}" | "${FAILED}" | "FAILED" | "failed" | "FAIL" | "fail" | "${KO}") _result="${_failureColor}";
                                                                                            ;;
    IN_PROGRESS | "${IN_PROGRESS}") _result="${_inProgressColor}";
                                    ;;
    *) _result="${_defaultColor}";
       ;;
  esac

  export RESULT="${_result}";
}

# fun: LOGGING.retrieveLevelPositionInLogPrefix
# api: private
# txt: Retrieves the position of the log level in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the level position.
# use: LOGGING.retrieveLevelPositionInLogPrefix; echo "level -> ${RESULT}";
function LOGGING.retrieveLevelPositionInLogPrefix() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_LEVEL_POSITION;
}

# fun: LOGGING.retrieveLogNamespace
# api: private
# txt: Retrieves the log namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log namespace.
# use: LOGGING.retrieveLogNamespace; echo "namespace: ${RESULT}";
function LOGGING.retrieveLogNamespace() {
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";
  DW.getGlobalString "${_moduleName}" LOG_CATEGORY_NAMESPACE;
  local _namespace="${RESULT}";
  DW.getGlobalString "${_moduleName}" LOG_CATEGORY;
  local _category="${RESULT}";
  DW.getScriptName;
  local _scriptName="${RESULT}";

  local _result;

  if isEmpty "${_namespace}"; then
    if isEmpty "${_scriptName}" ; then
      _result="?";
    else
      _result="$(basename ${_scriptName} .sh)";
    fi
  fi

  if isNotEmpty ${_category} ; then
    _result="${_result}:${_category}";
  fi

  export RESULT="${_result}";
}

# fun: LOGGING.processLogOutcomeColors SUCCESS|FAILURE|IN_PROGRESS
# api: private
# txt: Processes the log outcome colors based on given outcome and text.
#      Call LOGGING.getLogOutcomeColorsVariableName afterwards to use them.
# opt: SUCCESS|FAILURE|IN_PROGRESS: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogOutcomeColors SUCCESS "done";
function LOGGING.processLogOutcomeColors() {
  local _keyword="${1}";
  checkNotEmpty "SUCCESS|FAILURE|IN_PROGRESS" "${_keyword}" 1;
  LOGGING.checkSuccessFailureOrInProgress "${_keyword}" 1;
  local result=();
  local _aux="";
  LOGGING.retrieveKeywordColor "${_keyword}";
  local _keywordColor="${RESULT}";
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  LOGGING.getLogOutcomeColorsVariableName;
  local -n _logOutcomeColors=${RESULT};
  _len=$((${#_logOutcomeColors[@]} - 1));

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    IFS="${_oldIFS}";
    _logOutcomeColors[${_i}]="${_logOutcomeColors[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _logOutcomeColors[${_outcomeTextPosition}]="${_keywordColor}";
}

# fun: LOGGING.processLogOutcomeTokens text
# api: private
# txt: Processes the tokens composing the log outcome.
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogOutcomeTokens "done";
function LOGGING.processLogOutcomeTokens() {
  local _text="${1}";
  checkNotEmpty text "${_text}" 1;

  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_TOKENS;
  local -n _logOutcomeTokens=${RESULT};
  _len=$((${#_logOutcomeTokens[@]} - 1));

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _logOutcomeTokens[${_i}]="${_logOutcomeTokens[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _logOutcomeTokens[${_outcomeTextPosition}]="${_text}";
}

# fun: LOGGING.retrieveLogPrefix category TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Retrieves the log prefix.
# opt: category: The log category.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.retrieveLogPrefix "cat" DEBUG; echo "log prefix -> ${RESULT}";
function LOGGING.retrieveLogPrefix() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  local _level="${2}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 2;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 2;

  local _result="$(LOGGING.echoColorAwareLogPrefix "${_category}" ${FALSE} "${_level}")";
  export RESULT="${_result}";
}

# fun: LOGGING.retrieveLogPrefixToken TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Retrieves the log prefix token, depending on the given log level.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE if the token is defined; 1/FALSE otherwise.
# txt: if the function returns 0/TRUE, The variable RESULT contains the log prefix token.
# use: if LOGGING.retrieveLogPrefixToken TRACE; then echo "Log prefix token: ${RESULT}"; fi
function LOGGING.retrieveLogPrefixToken() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  local -i _rescode;
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" "${_level}_LOG_PREFIX_TOKEN";
  _rescode=$?;

  return ${_rescode};
}

# fun: LOGGING.processLogPrefixTokens category TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Processes the tokens composing the log prefix.
# opt: category: The log category.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogPrefixTokens "a:b:c" DEBUG;
function LOGGING.processLogPrefixTokens() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;
  local _level="${2:-INFO}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 2;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 2;

  LOGGING.retrieveLogPrefixToken "${_level}";
  _level="${RESULT}";
  local result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _lastIndex;
  local -i _timestampPosition;
  local -i _category_position;
  local -i _levelPosition;

  LOGGING.getLogPrefixTokensVariableName;
  local -n _logPrefixTokens=${RESULT};
  _lastIndex=$((${#_logPrefixTokens[@]} - 1));

  local _oldIFS="${IFS}";
  #  IFS=$' \t\n';
  IFS="${DWIFS}";
  for _i in $(seq 0 ${_lastIndex}); do
    IFS="${_oldIFS}";
    _logPrefixTokens[${_i}]="${_logPrefixTokens[${_i}]}";
  done
  IFS="${_oldIFS}";

  LOGGING.retrieveLogTimestamp;
  _timestamp="${RESULT}";
  LOGGING.retrieveTimestampPositionInLogPrefix;
  _timestampPosition=${RESULT};
  _logPrefixTokens[${_timestampPosition}]="${_timestamp}";
  LOGGING.retrieveCategoryPositionInLogPrefix;
  _categoryPosition=${RESULT};
  _logPrefixTokens[${_categoryPosition}]="${_category}";
  LOGGING.retrieveLevelPositionInLogPrefix;
  _levelPosition=${RESULT};
  _logPrefixTokens[${_levelPosition}]="${_level}";
}

# fun: LOGGING.retrieveLogTimestamp
# api: private
# txt: Retrieves the timestamp used for logging.
# txt: Override LOG_TIMESTAMP to modify the timestamp format.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp.
# use: LOGGING.retrieveLogTimestamp; echo "The log timestamp is ${RESULT}";
function LOGGING.retrieveLogTimestamp() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LOG_TIMESTAMP_FORMAT;
  export RESULT="$(date "${RESULT}")";
}

# fun: LOGGING.retrieveOutcomeTextPositionInLogOutcome
# api: private
# txt: Retrieves the position of the outcome token in the log outcome colors array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the outcome text position.
# use: LOGGING.retrieveOutcomeTextPositionInLogOutcome; echo "outcome text -> ${RESULT}";
function LOGGING.retrieveOutcomeTextPositionInLogOutcome() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_OUTCOME_TEXT_POSITION;
}

# fun: LOGGING.retrieveTimestampPositionInLogPrefix
# api: private
# txt: Retrieves the position of the timestamp in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp position.
# use: LOGGING.retrieveTimestampPositionInLogPrefix; echo "timestamp -> ${RESULT}";
function LOGGING.retrieveTimestampPositionInLogPrefix() {
  LOGGING.getModuleName;
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_TIMESTAMP_POSITION;
}

# fun: LOGGING.setLastLog message?
# api: private
# txt: Annotates the last log message.
# opt: message: The message. Optional.
# txt: Returns 0/TRUE always.
# use: LOGGING.setLastLog "Operation in progress";
function LOGGING.setLastLog() {
  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LAST_LOG "${@}";
}

# fun: getLastLog
# api: public
# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: RESULT contains the last log.
# use: getLastLog; echo "Last log: ${RESULT}";
function LOGGING.getLastLog() {
  LOGGING.getModuleName;
  DW.getGlobalString "${RESULT}" LAST_LOG;
}

# fun: logInfo message
# api: public
# txt: Logs a message as "info".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfo "Operation in progress";
function logInfo() {
  if isInfoEnabled; then
    checkNotEmpty message "${1}" 1;
    LOGGING.logStuff INFO "$@";
  fi
}

# fun: logInfoFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfoFromStdin <<<"Operation in progress";
function logInfoFromStdin() {
  if isInfoEnabled; then
    local _line;
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff INFO "${_line}";
      fi
    done
  fi
}

# fun: logInfoFile file
# api: public
# txt: Logs the contents of a file as "info".
# opt: file: The file containing the text to log.
# txt: Returns 0/TRUE always.
# use: logInfoFile /tmp/my-log.txt;
function logInfoFile() {
  if isInfoEnabled; then
    checkNotEmpty file "${1}" 1;
    local line;
    cat "${1}" | while IFS='' read -r line; do LOGGING.logStuff INFO "${line}"; done
  fi
}

# fun: logInfoResult SUCCESS|FAILURE message
# api: public
# txt: Logs the outcome of an operation as "info".
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfoResult SUCCESS "done";
function logInfoResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isInfoEnabled; then
    checkNotEmpty "SUCCESS|FAILURE" "${_outcome}" 1;
    LOGGING.checkSuccessOrFailure "${_outcome}" 1;
    checkNotEmpty message "${_message}" 2;

    LOGGING.logStuffResult INFO "${_outcome}" "${_message}";
  fi
}

# fun: logResult TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE message
# api: public
# txt: Logs the outcome of an operation, as "info", under a certain level.
# txt: The level is assumed to be enabled already.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: logResult SUCCESS "done";
function logResult() {
  local _level="${1}";
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1;
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1;
  shift;
  local _outcome="${1}";
  checkNotEmpty outcome "${_outcome}" 2;
  LOGGING.checkSuccessOrFailure "${_outcome}" 2;
  shift;
  local _message="${@}";
  checkNotEmpty message "${_message}" 3;

  LOGGING.logStuffResult "${_level}" "${_outcome}" "${_message}";
}

# fun: logTrace message
# api: public
# txt: Logs given message under the "trace" level.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logTrace "Operation in progress";
function logTrace() {
  if isTraceEnabled; then
    checkNotEmpty message "${1}" 1;
    LOGGING.logStuff TRACE "$@";
  fi
}

# fun: logTraceFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logTraceFromStdin <<<"Operation in progress";
function logTraceFromStdin() {
  if isTraceEnabled; then
    local _line;
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff TRACE "${_line}";
      fi
    done
  fi
}

# fun: logTraceFile file
# api: public
# txt: Logs the contents of given file, under the "trace" level.
# opt: file: The file to log.
# txt: Returns 0/TRUE always.
# use: logTraceFile /tmp/my-log.txt;
function logTraceFile() {
  if isTraceEnabled; then
    local _file="${1}";
    checkNotEmpty file "${_file}" 1;
    local line;
    cat "${_file}" 2> /dev/null | while IFS='' read -r line; do LOGGING.logStuff TRACE "${line}"; done
  fi
}

# fun: logTraceResult SUCCESS|FAILURE message
# api: public
# txt: Logs given text as a log result, under the "trace" level.
# opt: SUCCESS|FAILURE: The keyword.
# opt: message: The result message to log.
# txt: Returns 0/TRUE always.
# use: logTraceResult SUCCESS "Operation completed";
function logTraceResult() {
  local _outcome="${1}";
  shift;
  local _message="${@}";

  if isTraceEnabled; then
    checkNotEmpty outcome "${_outcome}" 1;
    LOGGING.checkSuccessOrFailure "${_outcome}" 1;
    checkNotEmpty message "${_message}" 2;
    LOGGING.logStuffResult TRACE "${_outcome}" "${_message}";
  fi
}

# fun: resolveVerbosity
# api: public
# txt: Retrieves the verbosity flag.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains '-vv' if trace is enabled; '-v' if debug is enabled; empty string otherwise.
# use: resolveVerbosity;
function resolveVerbosity() {
  local result="";

  if isTraceEnabled; then
    result="-vv";
  elif isDebugEnabled; then
    result="-v";
  elif isInfoEnabled; then
    result="";
  fi;

  export RESULT="${result}";
}

# fun: setDebugEnabled
# api: public
# txt: Enables the "debug" level.
# txt: Returns 0/TRUE always.
# use: setDebugEnabled
function setDebugEnabled() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_DEBUG ${TRUE};
  setInfoEnabled;
}

# fun: setInfoEnabled
# api: public
# txt: Enables the "info" level.
# txt: Returns 0/TRUE always.
# use: setInfoEnabled;
function setInfoEnabled() {
  setQuietMode ${FALSE};
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_INFO ${TRUE};
}

# fun: setLogCategory category
# api: public
# txt: Specifies the log category.
# opt: category: The log category.
# txt: Returns 0/TRUE always.
# use: setLogCategory;
function setLogCategory() {
  local _category="${1}";

  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LOG_CATEGORY "${_category}";
}

# fun: setLogCategoryNamespace namespace
# api: public
# txt: Sets the log category namespace.
# opt: namespace: The namespace.
# txt: Returns 0/TRUE always.
# use: setLogCategoryNamespace "processing";
function setLogCategoryNamespace() {
  local _namespace="${1}";
  checkNotEmpty namespace "${_namespace}" 1;

  LOGGING.getModuleName;
  DW.setGlobalString "${RESULT}" LOG_CATEGORY_NAMESPACE "${_namespace}";
}

# fun: setQuietMode mode
# api: public
# txt: Sets the quiet mode on or off.
# opt: mode: The mode (0/TRUE or 1/FALSE).
# txt: Returns 0/TRUE always.
# use: setQuietMode ${TRUE};
function setQuietMode() {
  local _mode="${1}";
  checkNotEmpty mode "${_mode}" 1;

  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_QUIET ${_mode};
}

# fun: setTraceEnabled
# api: public
# txt: Enables the trace level.
# txt: Returns 0/TRUE always.
# use: setTraceEnabled;
function setTraceEnabled() {
  LOGGING.getModuleName;
  DW.setGlobalInt "${RESULT}" LOG_TRACE ${TRUE};
  setDebugEnabled;
}

# fun: logToFile file
# api: public
# txt: Appends all logging to given file.
# opt: file: The file.
# txt: Returns 0/TRUE if the file exists and is readable; 1/FALSE otherwise.
# use: if logToFile "/tmp/logging"; then echo "Logging in /tmp/logging"; fi
function logToFile() {
  local _file="${1}";
  checkNotEmpty file "${_file}" 1;

  local -i _rescode=${FALSE};

  logInfo -n "Adding log file ${_file}";
  if fileExists "${_file}" && fileIsReadable "${_file}"; then
    _rescode=${TRUE};
    LOGGING.getLogFilesVariableName;
    local -n _logFiles="${RESULT}";

    _logFiles[${#_logFiles[@]}]="${_file}";
    logInfoResult SUCCESS "done";
  else
    logInfoResult FAILURE "failed";
  fi

  return ${_rescode};
}

# fun: LOGGING.getLogFilesVariableName
# api: private
# txt: Retrieves the name of the variable containing the log files.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the log files.
# use: LOGGING.getLogFilesVariableName; local -n logFiles=${RESULT}
function LOGGING.getLogFilesVariableName() {
  LOGGING.getModuleName;
  DW.getGlobalVariableName "${RESULT}" LOG_FILES;
}

# fun: LOGGING.logToFiles msg+
# api: private
# txt: Appends a log message to all defined logging files.
# opt: msg: The message to log.
# txt: Returns 0/TRUE always.
# use: LOGGING.logToFiles "Logging sample";
function LOGGING.logToFiles() {
  local _msg="${@}";
  checkNotEmpty msg "${_msg}" 1;

  LOGGING.getLogFilesVariableName;
  local -n _logFiles="${RESULT}";

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  local _file;
  for _file in ${_logFiles[@]}; do
    IFS="${_oldIFS}";
    echo -n "${_msg}" >> "${_file}" 2> /dev/null;
  done
  IFS="${_oldIFS}";

  return ${_rescode};
}

# fun: LOGGING.logToFilesAnEmptyLine
# api: private
# txt: Appends an empty line to all defined logging files.
# txt: Returns 0/TRUE always.
# use: LOGGING.logToFilesAnEmptyLine;
function LOGGING.logToFilesAnEmptyLine() {
  LOGGING.getLogFilesVariableName;
  local -n _logFiles="${RESULT}";

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  local _file;
  for _file in ${_logFiles[@]}; do
    IFS="${_oldIFS}";
    echo >> "${_file}" 2> /dev/null;
  done
  IFS="${_oldIFS}";

  return ${TRUE};
}

# State
# env: SUCCESS: Indicates the operation has succeeded.
declare -igx SUCCESS=0;
# env: FAILURE: Indicates the operation has failed.
declare -igx FAILURE=1;
# env: IN_PROGRESS: Indicates the operation is in progress.
declare -igx IN_PROGRESS=2;
# env: UNDEFINED: Indicates the operation outcome is undefined.
declare -igx UNDEFINED=255;
# env: SUCCESS: The 'Success' literal.
declare -gx SUCCESS="Success";
# env: DONE: The 'done' literal.
declare -gx DONE="done";
# env: OK: The 'ok' literal.
declare -gx OK="ok";
# env: FAILURE: The 'Failure' literal.
declare -gx FAILURE="Failure";
# env: FAILED: The 'failed' literal.
declare -gx FAILED="failed";
# env: KO: The 'ko' literal.
declare -gx KO="ko";

# fun: LOGGING.defaultState
# api: private
# txt: Restores the default state of the module.
# txt: Returns 0/TRUE always.
# use: LOGGING.defaultState
function LOGGING.defaultState() {
  LOGGING.getBuiltinSuccessKeywordsVariableName;
  local -n _successKeywordsVariableName=${RESULT};
  _successKeywordsVariableName[${#_successKeywordsVariableName[@]}]="${SUCCESS}";
  _successKeywordsVariableName[${#_successKeywordsVariableName[@]}]="${DONE}";
  _successKeywordsVariableName[${#_successKeywordsVariableName[@]}]="${OK}";

  LOGGING.getBuiltinFailureKeywordsVariableName;
  local -n _failureKeywordsVariableName=${RESULT};
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${ERROR}";
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${FAILURE}";
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${FAILED}";
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${KO}";
}

# fun: LOGGING.resetState
# api: private
# txt: Initializes the module state.
# txt: Returns 0/TRUE always.
# use: LOGGING.resetState
function LOGGING.resetState() {
  LOGGING.getModuleName;
  local _moduleName="${RESULT}";

  # env: The built-in success keywords.
  DW.declareGlobalArray "${_moduleName}" BUILTIN_SUCCESS_KEYWORDS;

  # env: The built-in failure keywords.
  DW.declareGlobalArray "${_moduleName}" BUILTIN_FAILURE_KEYWORDS;

  # env: LOG_STACK: The stack used to manage logging.
  DW.declareGlobalArray "${_moduleName}" LOG_STACK;
  # env: LOG_CATEGORY_STACK: The stack of log categories.
  DW.declareGlobalArray "${_moduleName}" LOG_CATEGORY_STACK;
  # env: LOG_CATEGORY_NAMESPACE: The namespace of the log category.
  DW.declareGlobalString "${_moduleName}" LOG_CATEGORY_NAMESPACE;
  # env: LOG_LEVEL_STACK: The stack of log levels.
  DW.declareGlobalArray "${_moduleName}" LOG_LEVEL_STACK;
  # env: LOG_TRACE: Whether to print TRACE messages.
  DW.declareGlobalInt "${_moduleName}" LOG_TRACE ${FALSE};
  # env: LOG_DEBUG: Whether to print DEBUG messages.
  DW.declareGlobalInt "${_moduleName}" LOG_DEBUG ${FALSE};
  # env: LOG_INFO: Whether to print INFO messages.
  DW.declareGlobalInt "${_moduleName}" LOG_INFO ${TRUE};
  # env: LOG_QUIET: Whether to disable logging messages.
  DW.declareGlobalInt "${_moduleName}" LOG_QUIET ${FALSE};
  # env: LOG_OUTCOME_TOKENS: The tokens used for log outcomes.
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_TOKENS;
  # env: LOG_OUTCOME_COLORS: The colors used for log outcomes.
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_COLORS;
  # env: DEFAULT_TERM_WIDTH: The default term width.
  DW.declareGlobalInt "${_moduleName}" DEFAULT_TERM_WIDTH;
  # env: LOG_LINE_OPEN: Whether the current log line is open.
  DW.declareGlobalInt "${_moduleName}" LOG_LINE_OPEN ${FALSE};
  # env: LAST_LOG: The last log message.
  DW.declareGlobalString "${_moduleName}" LAST_LOG;
  # env: LAST_LOG_LEVEL: The last log level.
  DW.declareGlobalInt "${_moduleName}" LAST_LOG_LEVEL;
  # env: NESTED_TASK_IN_PROGRESS: The symbols used to represent nested tasks in progress.
  DW.declareGlobalString "${_moduleName}" NESTED_TASK_IN_PROGRESS "....";
  # env: LOG_TIMESTAMP_FORMAT: The date format.
  DW.declareGlobalString "${_moduleName}" LOG_TIMESTAMP_FORMAT "+%Y/%m/%d %H:%M:%S";
  # env: LOG_OUTCOME_SEPARATOR: The separator used when printing log outcomes.
  DW.declareGlobalString "${_moduleName}" LOG_OUTCOME_SEPARATOR " ";
  # env: LOG_NESTED_INDENTATION: The indentation used for nested logs.
  DW.declareGlobalString "${_moduleName}" LOG_NESTED_INDENTATION "  ";

  # env: DEFAULT_LOG_PREFIX_COLOR: The default color used for log prefixes.
  DW.declareGlobalString "${_moduleName}" DEFAULT_LOG_PREFIX_COLOR GRAY;
  # env: DEFAULT_LOG_OUTCOME_COLOR: The default color used for outcomes.
  DW.declareGlobalString "${_moduleName}" DEFAULT_LOG_OUTCOME_COLOR GRAY;
  # env: DEFAULT_LOG_RESUMING_TASK_COLOR: The default color used when resuming tasks.
  DW.declareGlobalString "${_moduleName}" DEFAULT_LOG_RESUMING_TASK_COLOR GRAY;

  # env: LOG_PFEFIX_COLORS: The colors used in log prefixes.
  DW.declareGlobalArray "${_moduleName}" LOG_PREFIX_COLORS BLUE CYAN YELLOW MAGENTA YELLOW RED BLUE;

  # env: LOG_PREFIX_TOKENS: The tokens used in log prefixes.
  DW.declareGlobalArray "${_moduleName}" LOG_PREFIX_TOKENS "[" "timestamp" "<" "category" ">" "logLevel" "]";

  # env: LOG_PREFIX_TIMESTAMP_POSITION: The position of the timestamp in LOG_PREFIX_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_PREFIX_TIMESTAMP_POSITION 1;
  # env: LOG_PREFIX_CATEGORY_POSITION: The position of the category in LOG_PREFIX_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_PREFIX_CATEGORY_POSITION 3;
  # env: LOG_PREFIX_LEVEL_POSITION: The position of the level in LOG_PREFIX_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_PREFIX_LEVEL_POSITION 5;

  # env: INFO_LOG_PREFIX_TOKEN: The symbol used to represent INFO level.
  DW.declareGlobalString "${_moduleName}" INFO_LOG_PREFIX_TOKEN ".";
  # env: DEBUG_LOG_PREFIX_TOKEN: The symbol used to represent DEBUG level.
  DW.declareGlobalString "${_moduleName}" DEBUG_LOG_PREFIX_TOKEN "o";
  # env: TRACE_LOG_PREFIX_TOKEN: The symbol used to represent TRACE level.
  DW.declareGlobalString "${_moduleName}" TRACE_LOG_PREFIX_TOKEN "O";

  # env: LOG_OUTCOME_COLORS: The colors used when printing the operation outcome.
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_COLORS CYAN WHITE CYAN;

  # env: LOG_OUTCOME_TOKENS: The tokens used when printing the operation outcome.
  DW.declareGlobalArray "${_moduleName}" LOG_OUTCOME_TOKENS "[" "done" "]";

  # env: LOG_OUTCOME_TEXT_POSITION: The position of the text in LOG_OUTCOME_TOKENS.
  DW.declareGlobalInt "${_moduleName}" LOG_OUTCOME_TEXT_POSITION 1;

  # env: LOG_FILES: The files to write logging to.
  DW.declareGlobalArray "${_moduleName}" LOG_FILES;
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
