# mod: color
# api: public
# txt: Functions to create color constants.

# fun: COLOR.getModuleName
# api: private
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: COLOR.getModuleName; echo "Module: ${RESULT}";
function COLOR.getModuleName() {
  export RESULT="COLOR";
  return ${TRUE};
}

# fun: getSuccessColor
# api: public
# txt: Retrieves the color used to represent success.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the color.
# use: getSuccessColor; echo "success color: ${RESULT}";
function getSuccessColor() {
  COLOR.getModuleName;
  DW.getGlobalString "${RESULT}" SUCCESS_COLOR;
}

# fun: setSuccessColor color
# api: public
# txt: Specifies the color to use to represent success.
# opt: color: The color for success.
# txt: Returns 0/TRUE always.
# use: setSuccessColor GREEN;
function setSuccessColor() {
  local _color="${1}";
  checkNotEmpty color "${_color}" 1;

  COLOR.getModuleName;
  DW.declareGlobalString "${RESULT}" SUCCESS_COLOR "${_color}";
}

# fun: getFailureColor
# api: public
# txt: Retrieves the color used to represent failure.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the color.
# use: getFailureColor; echo "failure color: ${RESULT}";
function getFailureColor() {
  COLOR.getModuleName;
  DW.getGlobalString "${RESULT}" FAILURE_COLOR;
}

# fun: setFailureColor color
# api: public
# txt: Specifies the color to use to represent failure.
# opt: color: The color to use.
# txt: Returns 0/TRUE always.
# use: setFailureColor RED;
function setFailureColor() {
  local _color="${1}";
  checkNotEmpty color "${_color}" 1;

  COLOR.getModuleName;
  DW.declareGlobalString "${RESULT}" FAILURE_COLOR "${_color}";
}

# fun: getInProgressColor
# api: public
# txt: Retrieves the color used to represent in-progress tasks.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the color.
# use: getInProgressColor; echo "In-progress color: ${RESULT}";
function getInProgressColor() {
  COLOR.getModuleName;
  DW.getGlobalString "${RESULT}" IN_PROGRESS_COLOR;
}

# fun: setInProgressColor color
# api: public
# txt: Specifies the color used to represent in-progress tasks.
# opt: color: The color to use.
# txt: Returns 0/TRUE always.
# use: setInProgressColor YELLOW;
function setInProgressColor() {
  local _color="${1}";
  checkNotEmpty color "${_color}" 1;

  COLOR.getModuleName;
  DW.declareGlobalString "${RESULT}" IN_PROGRESS_COLOR "${_color}";
}

# fun: getNoColor
# api: public
# txt: Retrieves the value to use when we don't want to use colored logging.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the value for no color.
# use: getNoColor; echo "No color: ${RESULT}";
function getNoColor() {
  COLOR.getModuleName;
  DW.getGlobalString "${RESULT}" NO_COLOR;
}

# fun: getNoColorVariableName
# api: public
# txt: Retrieves the name of the variable containing the value to use when we don't want to use colored logging.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the value for no color.
# use: getNoColor; echo "No color: ${RESULT}";
function getNoColorName() {
  COLOR.getColorName NO_COLOR;
}

# fun: setNoColor color
# api: public
# txt: Specifies the value to use when we don't want to use colored logging.
# opt: color: The name of the color for no-colored texts.
# txt: Returns 0/TRUE always.
# use: setNoColor GRAY;
function setNoColor() {
  local _color="${1}";
  checkNotEmpty color "${_color}" 1;

  COLOR.getModuleName;
  DW.declareGlobalString "${RESULT}" NO_COLOR "${_color}";
}

# fun: buildColor name foreground background
# api: public
# txt: Builds a new color.
# opt: name: The color name.
# opt: foreground: The foreground value.
# opt: background: The background value.
# txt: Returns 0/TRUE always.
#      Exports [COLOR]_FG, [COLOR]_BG, LIGHT_[COLOR]_FG, UNDERSCORE_[COLOR]_FG, BLINK_[COLOR]_FG and CONCEALED_[COLOR]_FG variables.
# use: buildColor "GREEN" "32" "42";
function buildColor() {
  local _color="${1}";
  checkNotEmpty name "${_color}" 1;

  local _fgValue="${2}";
  checkNotEmpty foreground "${_fgValue}" 2;

  local _bgValue="${3}";
  checkNotEmpty background "${_bgValue}" 3;

  local result="";

  COLOR.getModuleName;
  local _moduleName="${RESULT}";

  #  upvar "${_color}" "\033[0;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "${_color}" "\033[0;${_fgValue}m";
#  upvar "${_color}_FG" "\033[0;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "${_color}_FG" "\033[0;${_fgValue}m";
#  upvar "${_color}_BG" "\033[${_bgValue}m";
  DW.setGlobalString "${_moduleName}" "${_color}_BG" "\033[${_bgValue}m";
#  upvar "LIGHT_${_color}_FG" "\033[1;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "LIGHT_${_color}_FG" "\033[1;${_fgValue}m";
#  upvar "UNDERSCORE_${_color}_FG" "\033[4;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "UNDERSCORE_${_color}_FG" "\033[4;${_fgValue}m";
#  upvar "BLINK_${_color}_FG" "\033[5;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "BLINK_${_color}_FG" "\033[5;${_fgValue}m";
#  upvar "INVERSE_${_color}_FG" "\033[7;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "INVERSE_${_color}_FG" "\033[7;${_fgValue}m";
#  upvar "CONCEALED_${_color}_FG" "\033[8;${_fgValue}m";
  DW.setGlobalString "${_moduleName}" "CONCEALED_${_color}_FG" "\033[8;${_fgValue}m";

  DW.getGlobalVariableName "${_moduleName}" "${_color}";
}

# fun: allowsColors
# api: public
# txt: Checks whether the terminal allows colors or not. If the variable DW_DISABLE_ANSI_COLORS is non-empty, colors are disabled.
# txt: Returns 0/TRUE if the terminal supports colors; 1/FALSE otherwise.
# use: if allowsColors; then ...; fi
function allowsColors() {
  local -i _rescode;

  local _cachedResult="${_DW_ALLOWS_COLORS}";

  if isEmpty "${_cachedResult}"; then
    local -i _disableColors=${FALSE};
    if isNotEmpty "${NO_COLOR}"; then
      _disableColors=${TRUE};
    elif   isNotEmpty "${USECOLOR}" \
        && areEqual "${USECOLOR}" "no"; then
      _disableColors=${TRUE};
    fi
    if isFalse ${_disableColors}; then
      local _colors="$(tput colors 2>&1)";
      if isNotEmpty "${_colors}"; then
        if isGreaterOrEqualTo "${_colors}" 8; then
          env | grep -e '^_=' | grep env > /dev/null 2>&1;
          if isTrue $?; then
            _rescode=${TRUE};
          else
            _rescode=${FALSE};
          fi
        else
          _rescode=${FALSE};
        fi
      else
        _rescode=${FALSE};
      fi;
    else
      _rescode=${FALSE};
    fi
    export _DW_ALLOWS_COLORS=${_rescode};
  else
    _rescode=${_cachedResult};
  fi

  return ${_rescode};
}

# fun: COLOR.getColorName symbol
# api: public
# txt: Retrieves the color name associated to given symbol.
# opt: symbol: The color symbol.
# txt: Returns 0/TRUE if the symbol is known; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the color name.
# use: if getColorName GRAY; then echo "color name: ${RESULT}"; fi
function COLOR.getColorName() {
  local _symbol="${1}";
  checkNotEmpty symbol "${_symbol}" 1;

  COLOR.getModuleName;
  local _moduleName="${RESULT}";
  DW.getGlobalVariableName "${_moduleName}" "${_symbol}";
}

# fun: getColorEscapeCode name defaultColor?
# api: public
# txt: Retrieves the color for given name.
# opt: name: The color name.
# opt: defaultColor: The fallback color. Optional.
# txt: Returns 0/TRUE if the color is defined; 1/FALSE otherwise.
# txt: The variable RESULT contains the color value, or the default if not defined.
# use: getColorEscapeCode RED;
function getColorEscapeCode() {
  local _colorSymbol="${1}";
  checkNotEmpty name "${_colorSymbol}" 1;

  local _defaultColorSymbol="${2}";
  if isEmpty "${_defaultColorSymbol}"; then
    getNoColor;
   _defaultColorSymbol="${RESULT}";
  fi
  local _result;
  local -i _rescode;

  if allowsColors; then
    COLOR.getColorName "${_colorSymbol}";
    local _colorVariableName="${RESULT}";
     if evalConstant "${_colorVariableName}"; then
       _result="${RESULT}";
    elif evalContant "${_defaultColorVariableName}"; then
      _result="${RESULT}";
    else
      exitWithErrorCode INTERNAL_ERROR "Error getting color ${_colorSymbol}";
    fi
  fi

  if isEmpty "${_result}"; then
    _result="${_defaultColorSymbol}";
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: resetColor
# api: public
# txt: Resets the color for future calls to "echo".
# txt: Returns 0/TRUE always.
# use: resetColor;
function resetColor() {
  getNoColor;
  getColorEscapeCode "${RESULT}";
  echo -en "${RESULT}";
}

# fun: COLOR.resetState
# api: private
# txt: Initializes the color state, depending on the script nesting level.
# txt: Returns 0/TRUE always.
# use: COLOR.resetState
function COLOR.resetState() {
  if allowsColors; then
    buildColor VOID 0 0;
    buildColor BLACK 30 0;
    buildColor RED 31 41;
    buildColor GREEN 32 42;
    buildColor YELLOW 33 43;
    buildColor BLUE 34 44;
    buildColor MAGENTA 35 45;
    buildColor CYAN 36 46;
    buildColor GRAY 37 47;
    buildColor BRIGHT_BLACK 90 100;
    buildColor BRIGHT_RED 91 101;
    buildColor BRIGHT_GREEN 92 102;
    buildColor BRIGHT_YELLOW 93 103;
    buildColor BRIGHT_BLUE 94 104;
    buildColor BRIGHT_MAGENTA 95 105;
    buildColor BRIGHT_CYAN 96 106;
    buildColor WHITE 97 107;

    setSuccessColor GREEN;
    setFailureColor RED;
    setInProgressColor BLUE;
    setNoColor GRAY;
  fi
}

# env: NO_COLOR: Whether to disable ANSI colors completely.
# env: USECOLOR: If set to 'no', disables ANSI colors completely.

# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
