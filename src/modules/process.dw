# mod: process
# api: public
# txt: Functions dealing with external processes.

# fun: isRunning filePath
# api: public
# txt: Checks if a process is running.
# opt: filePath: The path of the executable.
# txt: Returns 0/${TRUE} if the process is running; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the pid of the process.
# use: if isRunning /bin/bash; then
# use:   echo "bash pid: ${RESULT}";
# use: fi
function isRunning() {
  local _filePath="${1}";
  checkNotEmpty filePath "${_filePath}" 1;

  local _fileName="$(basename "${_filePath}")";
  local _result;
  _result=$(pidof "${_fileName}");
  local -i _rescode=$?;

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: halt seconds?
# api: public
# txt: Halts the process (keeps it paused forever).
# opt: seconds: The amount of seconds to sleep, periodically. Optional.
# txt: Doesn't return.
# use: halt;
function halt() {
  local _seconds="${1:-100}";

  while isTrue ${TRUE}; do
    sleep ${_seconds};
  done;
}

# fun: anotherProcessAlreadyRunning
# api: public
# txt: Checks if this script is already running.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if anotherProcessAlreadyRunning; then
# use:   echo "Another process already running";
# use: fi
function anotherProcessAlreadyRunning() {
  local -i _rescode=${FALSE};
  local _ownPid=$$;
  local _pid;

  DW.getScriptPath;
  local _scriptPath="${RESULT}";

  for _pid in $(pidof -x "${_scriptPath}"); do
    if ! areEqual "${_pid}" "${_ownPid}"; then
      _rescode=${TRUE};
      break;
    fi
  done

  return ${_rescode};
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
